\section{Challenges of large-scale build systems}

Summary of this section: \emph{What problem are we trying to solve?} We show several
common challenges for existing build languages, such as \textsc{Make},
\textsc{cmake}, \textsc{Ninja} and others (the list to be updated). Each
challenge is described in a separate section, with specific examples coming from
the GHC. We briefly outline the solutions and refer the reader for more details
coming in Sections~\ref{section-abstractions} and~\ref{section-dependencies}.

\subsection{Abstracting over patterns of dependencies}

Weak abstractions of \textsc{Make}:
\begin{itemize}
  \item Pattern rules: do not work in general
  \item Macros: untyped, Utterly Impenetrable 
\end{itemize}

By embedding the build system in Haskell we get access to its rich abstraction
facilities. See Section~\ref{section-abstractions} for more details.

\subsection{Programming model}

\textsc{Make}'s programming model: single global space of string variables. The
only way to control build parallelism is by introducing fake \emph{concurrency
reduction} dependencies. Also see: ``Recursive Make Considered Harmful'' by
Peter Miller, 1997. See Section~\ref{section-abstractions} for more details.

\subsection{Dynamic dependencies}

\textsc{Make} has no support for dynamic dependencies. \emph{Build phases}: do
not work in general. 

We handle dynamic dependencies using \textsc{Shake}'s oracles. See
Section~\ref{section-dependencies} for more details.

\subsection{Fine-grain dependencies}

\textsc{Make} supports only file dependencies, so it is impossible to depend
on anything finer, e.g. a single flag in a configuration file. Keeping flags
separately in different files is impractical. 

See Section~\ref{section-dependencies} for more details.

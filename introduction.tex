\section{Introduction}

A build system is a critical component of any software project. It's the
coal-face at which developers spend their days, so must be fast to run, produce
the outputs correctly, and provide all the features needed. Despite the
importance of writing good build systems, such endeavours remain a black art.
The build system for the Glasgow Haskell Compiler~(GHC)~\cite{ghc} has been
rewritten three times using \make{}~\cite{make}, and while lessons have been
learnt each time, the end result remains frustratingly complex. As an example:

\begin{lstlisting}
$$(foreach dep,$$($1_$2_DEP_COMPONENT_IDS),\
    $$$$($$(dep)_dist-$(if $(filter 0,$3),boot,install)\
        _PROGRAM_DEP_LIB))
\end{lstlisting}

Taking a look at \lst"$$($1_$2_DEP_COMPONENT_IDS)" -- this constructs a variable
name using the variables \lst"$1" and \lst"$2" (themselves macro arguments),
then resolves this variable. It then takes the value of that variable and
resolves it. The end result is almost impossible to predict. The definition site
of any individual symbol is hard to track down. Many are defined, redefined and
conditionally defined. While the first line is confusing, the second is
significantly more so, with 4 indirections of a computed variable.

Were this the only example in the build system, we might be able to solve it
with lots of documentation. But alas, this snippet is the rule, not the exception.

In this paper we show a better approach to designing large build systems. Our
approach is two pronged:

\begin{itemize}
\item  We use the latest innovations in build systems (specifically Shake,
\cite{shake}), combined with the abstraction power of functional programming (in
our case, Haskell \cite{haskell}), to remove much of the \textit{accidental
complexity} from the build system. By using sensible primitives that compose
nicely we are able to remove much of the heroism required from build system
maintenance.
\item We identify suitable abstractions for writing large build systems
\S\ref{sec:abstractions}. In particular we describe an embedded domain-specific
language (EDSL) for capturing much of the configuration of the build system
(which optimisation flags are required to which tools in which modes), cleanly
separating this configuration from the rest of the build system.
\end{itemize}

We have used our approach to write a new GHC build system \S\ref{sec:ghc}. The
new build system is about half the length of the previous one (5,824 lines as
opposed to 10,952). \todo{The new system has reasonable chunks of the old system
as comments. Should check non-comment and non-blank lines.} More satisfyingly,
the new build system remains intelligible, and hopefully will not require
further rewrites.

%  \item Motivating examples of mission-critical build systems, perhaps, from
%  Standard Chartered and/or Facebook?

~\\
\textbf{Contritubions}:
\begin{itemize}
  \item A convincing demonstration for the need of abstractions,
  their benefits for maintenance and use.
  \item Design pattern for a DSL and escape hatch (Neil)
  \item Particular set of abstractions for GHC.
  \item "New" abstractions in Shake: oracles, resources, unchanging files.
  \item How Shake solves make's problems
  \item Non-recursive Make Considered Harmful.
  \item Version 5 of GHC build system; the paper is informed by
  experience of a truly large scale build system (used to 
  have 800 files with N generated).
  \item Flag provenance tracking and simpler provenance as no
  generated files. 
\end{itemize}

\section{Background about Shake\label{sec:shake}}

Many of the issues raised in~\S\ref{sec:challenges} stem from the fact
that Make was never designed to be a programming language.  A
promising appoarch is, therefore, abandon Make in favour of an
embedded domain-specfic language (DSL), so that we have access to the full
static typing and abstraction facilities of the host language.
We did exactly this with GHC's build system, replacing Make with
Shake, a DSL embedded in Haskell~\cite{shake}. In this section we
recap the key ideas behind Shake, and also describe some of the additional
features provided by Shake, but not covered in the original paper. These
features are of general use, and all predate our efforts to replace the GHC build
system.

\subsection{Introduction\label{sec:shake_intro}}

As an example of a complete
small Shake build system, let us compile a C file into an object file:

\begin{lstlisting}[numbers=left,xleftmargin=2em,framexleftmargin=1.5em]
module Main(main) where
import Development.Shake
import System.FilePath

main :: IO ()
main = shake shakeOptions $ do
    want ["foo.o"]

    "*.o" %> \out -> do
        let src = out -<.> "c"
        need [src]
        cmd "gcc -o" out "-c" src
\end{lstlisting}

\noindent Following the code from top to bottom:

\begin{description}
\item[Line 1] declares a Haskell module. Shake is a Haskell library, so all
Shake build systems are written in Haskell and can make full use of other
Haskell libraries and Haskell abstractions (functions, modules, packages,
\lst'let' expressions etc).
\item[Line 2] imports the \lst'Development.Shake' module, which provides most of
the functions and types in Shake. Some of the Shake API is given in
Figure~\ref{fig:shake-api}.
\item[Line 3] imports the \lst'System.FilePath' module, which in this example
provides the \lst'-<.>' function to replace a file's extension.
\item[Lines 6] declares the \lst'main' function, which calls \lst'shake'. The
\lst'shake' function takes some options (parallelism settings, etc.), along with
a set of \lst'Rules', and executes the necessary rules.
\item[Line 7] calls \lst'want', to declare that after the build system has
finished we would like the file \lst'foo.o' to be available and up-to-date.
\item[Line 9] defines a rule to build \lst'*.o' files, namely those files which
end with the extension \lst'.o'. The \lst'%>' operator produces a rule of type
\lst'Rules' which takes a pattern on the left, and an \lst'Action' on the
right. The variable \lst'out' will be bound to the actual file being produced,
namely \lst'foo.o' in this example.
\item[Line 10] computes the name of the source file, in our case \lst'src = foo.c'.
\item[Line 11] uses the Shake function \lst'need' to ensure \lst'foo.c' has been built before
continuing, and to introduce a dependency that if \lst'foo.c' changes then this
rule will require rerunning.
\item[Line 12] uses the variable-arity function \lst'cmd' to execute the system
command \lst'gcc' with appropriate arguments to produce \lst'out' from
\lst'src'. Since the \lst'Action' type has an instance of \lst'MonadIO' we can
do any \lst'IO' operation at this point.
\end{description}

\begin{figure}
\begin{lstlisting}
#\vspace{-7mm}#
#\line(1,0){240}#
newtype Rules a = ... #\hspace{36.5mm}\textbf{\emph{Generic API}}#
   deriving#\,#(Monoid,#\,#Functor,#\,#Applicative,#\,#Monad)
newtype Action a = ...
   deriving#\,#(Functor,#\,#Applicative,#\,#Monad,#\,#MonadIO)

data ShakeOptions = ShakeOptions {shakeThreads :: Int, ...}
shakeOptions :: ShakeOptions

shake :: ShakeOptions -> Rules () -> IO ()
action :: Action a -> Rules ()

type ShakeValue a =
    (Show#\,#a, Typeable#\,#a, Eq#\,#a, Hashable#\,#a, Binary#\,#a, NFData#\,#a)
data EqualCost = EqualCheap | EqualExpensive | NotEqual

class (ShakeValue key, ShakeValue value) =>
        Rule key value where
    storedValue :: ShakeOptions ->
        key -> IO (Maybe value)
    equalValue :: ShakeOptions ->
        key -> value -> value -> EqualCost

rule :: Rule key value =>
    (key -> Maybe (Action value)) -> Rules ()
apply :: Rule key value => [key] -> Action [value]

data Resource
newResource :: String -> Int -> Rules Resource
withResource :: Resource -> Int -> Action a -> Action a
#\vspace{-5mm}#
#\line(1,0){240}#
type FilePattern = String#\hspace{25mm}\textbf{\emph{File-specific API}}#
want :: [FilePath] -> Rules ()
need :: [FilePath] -> Action ()
needed :: [FilePath] -> Action ()
orderOnly :: [FilePath] -> Action ()
(%>) :: FilePattern -> (FilePath -> Action ()) -> Rules ()
(?>) :: (FilePath -> Bool)#\,#->#\,#(FilePath -> Action#\,#())#\,#->#\,#Rules#\,#()
\end{lstlisting}

\todo{\textbf{Neil}: Include everything we use in the paper}
\caption{Shake API\label{fig:shake-api}}
\end{figure}

On the first execution, this example will start running the \lst'*.o' rule to
produce \lst'foo.o'. When execution gets to \lst'need [src]' this rule will stop
and the rule for \lst'foo.c' will be run. Shake provides a default rule for
files that do not match any other rules, which simply checks the file already
exists. After completing this simple rule, Shake will resume running the
\lst'*.o' rule, executing \lst'gcc' to build \lst'foo.o'.

The major source of Shake's expressive power is that in Shake a \lst'need' can
come at any point during a rule's \lst'Action'. In particular, we can perform
arbitrary computation including I/O, running system commands and examining files
produced by a previous \lst'need' before deciding which future \lst'need' to
perform. In contrast, in most build systems, all dependencies of a rule must be
given before the rule starts executing. We make extensive use of this additional
power throughout \S\ref{sec:abstractions}.

\subsection{Parsimonious rebuilding}

Both Make and Shake try to eliminate unnecessary rebuilding, but each
uses a different approach:

\begin{itemize}
\item In Make, a rule is rerun if \emph{the output does not exist, or if the
modification time of the output is earlier than any of the inputs}. In an example
similar to that above, \lst'gcc' would be rerun if either \lst'foo.o' did not
exist, or if the modification time of \lst'foo.o' was earlier than that of
\lst'foo.c'.
\item In Shake, a rule is rerun if \emph{any of the inputs or outputs have changed since the
last run of the rule}. In our example, Shake will rerun \lst'gcc' if
either \lst'foo.c' or \lst'foo.o' does not exist or if either file
changes modification time from when the rule was last run (or more
generally, if either file changes contents, see
\S\ref{sec:file-contents}).
\end{itemize}
\noindent
Shake achieves this result by storing the inputs and outputs after a rule
completes in a per-project database, and rerunning a rule if anything has
changed (and thus the result could be expected to change). The Shake's approach
has a number of advantages: (1) we can track things that aren't files as in
\S\ref{sec:polymorphic}; (2) we can depend on a more refined measure than
modification time as in \S\ref{sec:file-contents}; (3) we are robust to system
time changes or extracting old files from backups; (4) the execution of a rule
does not need to update its output to avoid future rebuilds. The final point is
often worked around in Make by using \emph{stamp files} to provide a modification
time but having no actual content -- Shake simplifies this common use-case.

In fact, by decoupling dependencies from modification times, Shake allows
a richer notion ``dependency'', which turns out to be very useful in practice
as we now review.

\subsection{Pre-use dependencies: \lst'need'\label{sec:need}}

The call \lst'need [src]' on line 11 tells Shake that \lst'foo.c' is needed
to build \lst'foo.o'. But note that this dependency need only be announced
when Shake decides to run the rule to built \lst'foo.c'; and that the
build system author is free to use arbitary I/O actions to find which files
are needed. This is much more dynamic than Make's static dependencies,
a feature that turns out be extremely important in practice (\S\ref{sec:dynamic-deps}).

\subsection{Post-use dependencies: \lst'needed'\label{sec:needed}}

Looking at our first example, the object gets recompiled if the C source file
changes (via the call to \lst'need [src]', line 11).
But a C file may \lst'#include' any number of header files, and changes
to these headers will also affect the resulting object. While it is possible to
write our own code to search for transitively included headers
\cite[\S6.4]{shake}, a simpler alternative is to reuse the logic already present
in \lst'gcc'. The \lst'gcc' compilation command (\lst'-c') can also take a flag
\lst'-M' to print out a \lst'Makefile' listing all headers that were used by the
compilation. We can integrate this into our example by replacing the final
line with:

\begin{lstlisting}
Stdout makefile <- cmd "gcc -M -o" out "-c" src
need $ makefileDepends makefile
\end{lstlisting}

\noindent We use \lst'Stdout' to capture the output of \lst'cmd', then
\lst'makefileDepends' to parse the \lst'Makefile' and return all dependencies
\footnote{Using the \lst'parseMakefile' helper function in Shake we can define
\lst'makefileDepends = concatMap snd . parseMakefile'.}. After obtaining the
list of dependencies we \lst'need' them, making them inputs to this rule, and
ensuring that if a header changes the object will be rebuilt.

\simon{I have rewritten this paragraph; Neil pls check.}
There is something a bit fishy here: \emph{after} building \lst'foo.o' we
announce that its \emph{pre-requisites} are \lst'bar.h' and \lst'wibble.h'.
That is certainly useful if \lst'bar.h' is a source file because
then Shake will know to re-build \lst'foo.o' if the user edits \lst'bar.h'.
But if \lst'bar.h' is itself built by the build system from something else,
we have told Shake ``too late''.

% However, for this use case, the \lst'need' function is actually a little
% \emph{too} powerful. The \lst'need' will cause Shake to suspend the \lst'*.o'
% rule, build the dependencies, and then resume the remainder of the rule. But
% since the header files were \emph{already} used by \lst'gcc', if they change
% then the result will be inconsistent, since the object file will reflect the
% previous header contents.

We solve this problem by using \lst'needed' instead of \lst'need', which
combines \lst'need' which an assertion that the file does not change as a result
of building, and thus the result is consistent. In the common case of the header
files being source files, the associated rule will be the default file rule,
which does not modify the file, and the assertion will not trigger.

\subsection{Order-only dependencies: \lst'orderOnly'}

We have seen how \lst'needed' can be safely used for source files, but what
about generated files? Imagine we have a rule to build \lst'config.h' from a
configuration data file. With the existing formulation,
\lst'needed ["config.h"]' will raise an error if the configuration data has
changed and \lst'config.h' is not up-to-date. One solution is to \lst'need ["config.h"]'
\emph{before} executing \lst'gcc'. This solution is safe -- the file
\lst'config.h' will always be built before it is used and will not change when
\lst'needed' (since it has already been built). However, this solution
introduces a dependency on \lst'config.h', which causes any object file that
does \emph{not} include \lst'config.h' to rebuild unnecessarily if
\lst'config.h' changes.

A better solution is to use order-only dependencies, with the expression
\lst'orderOnly ["config.h"]'. This expression ensures that \lst'config.h' has
been built and is up-to-date before continuing, but does not introduce a
dependency on \lst'config.h'; that is, if \lst'config.h' changes
the rule will not be re-run. Afterwards, if the file turns out to have been
required, \lst'needed' can be used to express the dependency.

So, for a given rule; \lst'orderOnly' ensures that a (potential) input
file has been built before the rule is run; and \lst'needed' ensures
that the rule is re-run if an (actual) input file changes. Combining
the two we obtain the equivalence:

\begin{lstlisting}
need xs === (orderOnly xs >> needed xs)
\end{lstlisting}

\noindent Although in practice both \lst'orderOnly' and \lst'needed' can be
implemented on top of the \lst'need' primitive.

\subsection{Polymorphic dependencies\label{sec:polymorphic}}

While build-systems are typically focused around files, the core of Shake is
fully polymorphic, operating on objects that are uniquely labelled by a
\lst'key' and have rules that produce a \lst'value'.
In the case of files, they key is the filename and the value is the modification 
time, or content hash (\S\ref{sec:file-contents}).
Using the polymorphic API we can define new types of rules to track additional
dependencies.
This polymorphic API, and the file-specific API built on top
of it, are presented in corresponding sections of Figure~\ref{fig:shake-api}.

As an example of a new type of rules, let us imagine that the actual compiler
name (\lst'gcc') is obtained from a configure script that p
roduces a
configuration file containing many key/value pairs. The \lst'*.o' rule could
\lst'need' the configuration file, and parse it to extract the compiler name,
but that would be wildly over-conservative: \emph{any} change to the
configuration file would cause \emph{all} rules using the C compiler to rebuild, 
\emph{even if the compiler name did not change}. Alternatively, we could have rules to split
the single configuration file into one file per key, where each file is only
updated if that key changes, but that might result in thousands of files.
Instead, we can define a rule to map from configuration keys to values.

\begin{lstlisting}
newtype ConfigKey = ConfigKey String deriving
    (Show#\,#a, Typeable#\,#a, Eq#\,#a, Hashable#\,#a, Binary#\,#a, NFData#\,#a)

instance Rule ConfigKey String where
    storedValue _ _ = return Nothing

main = shake shakeOptions $ do
    rule $ \(ConfigKey key) -> Just $ do
        src <- readFile' "config.file"
        return $ parseConfig src Map.! key

    "*.o" %> \out -> do
        cc <- apply [ConfigKey "cc"]
        ...
        cmd cc "-o" out "-c" src

parseConfig :: String -> Map String String
\end{lstlisting}
\simon{This code is hard to understand.}
\simon{It looks as though the config file will be parsed once for each key.  Is that right?}
We use two new functions, \lst'rule' and \lst'apply', whose types are given in
Figure~\ref{fig:shake-api}:
\begin{itemize}
\item \lst'rule' takes a function that, for any given key, tells how to get its value
(ignore the \lst'Maybe' in the type for now), and stores the function in Shake's database.
In our example, the function reads the config file, parses it to get a finite map, and
looks the key up in that map.
\item \lst'apply' takes a key and looks up the corresponding value. \simon{Why a list of keys?}
\end{itemize}
Crucially, Shake treats these computation incrementally: it parses the
file only once, regardless of the number of uses of \lst'apply'; and
it re-runs rules that look up key \lst'ConfigKey "cc"' only if the
name of the C compiler actually changes.  So if file \lst'config.file' changes,
Shake will re-run the rule installed by the call to `rule`, but if \lst'cc' does
not change, the \lst'*.o' rule will not re-run.

% This code defines a fresh type \lst'ConfigKey' to serve as the key for the rule.
% We define a \lst'Rule' instance so Shake rules can operate on \lst'ConfigKey'
% keys, declaring the associated value to be of type \lst'String'. We are only
% required to implement the \lst'storedValue' method, where we declare that the
% rule producing the config key is not stored separately on disk.
% 
% Next we use \lst'rule' to describe how to generate the value associated with
% \lst'ConfigKey', using \lst"readFile'" to read the config file, and assuming the
% existence of a suitable \lst'parseConfig' function. We use \lst'apply' to force
% execution of the rule and introduce a dependency on the result.
% %For files, \lst'%>' is implemented in terms of \lst'rule', and \lst'need' is
% % implemented in terms of \lst'apply'.
% Now the \lst'*.o' rule will have the \emph{value} of the
% \lst'cc' key as a dependency, and if that value changes, all \lst'*.o' files will rebuild.

% \todo{Do we need to explain oracles? Just polymorphic rules aren't that much harder}
%
% The use of non-file rule types is common in large build systems, occurring ten times in our implementation of GHC's build system in \S\ref{sec:ghc}. To simplify such uses we define an oracle abstraction, allowing us to write:
%
% \begin{lstlisting}
% configKey <- addOracle $ \(ConfigKey key) -> do
%     src <- readFile' "config.file"
%     return $ parseConfig src Map.! key
%
% "*.o" %> \out -> do
%     cc <- configKey $ ConfigKey key
%     ...
% \end{lstlisting}
%
% Using oracles we are freed from defining our own \lst'Rule' instance and can use a type-safe version of \lst'apply' tailored to our particular oracle. The definition of oracles is only a handful of lines long, but sharply decreases the number of Shake concepts that must be understood to define non-file rules following the typical pattern. All non-file rules in GHC are implemented using oracles.

The use of non-file rule types is common in large build systems, occurring ten
times in our implementation of GHC's build system in \S\ref{sec:ghc}.
Polymorphic dependencies do not give any fundamental additional expressive power
over file rules, but they do provide:

\begin{itemize}
\item An easy way to get distinct keys, by using use of a freshly defined type.
\item Additional structure for keys and values, instead of hierarchical
filenames and binary content files. In particular keys can contain full
algebraic data types.
\item Greater granularity, by not forcing each rule to be backed by a separate
file. GHC's build system uses 6,677 non-file rules.
\end{itemize}

\subsection{Concurrency reduction\label{sec:concurrency-reduction}}

Like most build systems, Shake can run independent rules concurrently.
However, running too many rules in parallel can cause a computer to become overloaded,
spending much of its time switching between tasks instead of executing them.
Most build systems take an argument to set the maximum number of rules that can
be run in parallel (Shake has \lst'shakeThreads'), and typically that number
is based on the number of available CPUs. However, some rules may not be
independent:

\begin{itemize}
\item Some APIs are global in nature. If you run two programs that access the
\lst'Excel' API simultaneously things start to fail.
\item Many people have large numbers of CPUs, but only one slow rotating
hard-drive. Running many disk-heavy linker processes simultaneously can overload
the hard-drive.
\item Some proprietary software has licenses which limit the number of
concurrent processes, for example \lst'ModelSim'.
\end{itemize}

\noindent Rules using such limited \emph{resources} should not be run in
parallel even though they do not have explicit dependencies between them. Build systems
typically obey such constraints by setting an artifically low CPU limit, pausing rules
competing for the resource, or adding fake dependencies to seralise the rules.
All these solutions fail to make best use of the available CPUs, and the fake
dependencies are also fragile and tricky to implement.

Shake provides a \lst'Resource' abstraction that solves this problem directly.
A \lst'Resource' value represents a finite resource that multiple build rules can use;
such values are created with \lst'newResource' and used by \lst'withResource'. As an
example, only one set of calls to the \lst'Excel' API can occur at once, therefore
\lst'Excel' is a finite resource of quantity 1. We can write:

\begin{lstlisting}
want ["a.xls","b.xls"]
excel <- newResource "Excel" 1
"*.xls" %> \out ->
    withResource excel 1 $ cmd "excel" out ...
\end{lstlisting}

\noindent We create a new resource \lst'excel' of quantity 1, and then we call
\lst'withResource excel 1' to use it. Now we will never run two copies of
\lst'Excel' simultaneously, regardless of the \lst'shakeThreads' setting.
Moreover, the build system will never block waiting for the resource if there
are other rules that could be run. We use this approach to deal with the GHC
package database, which only permits one writer or multiple readers,
see~\S\ref{sec:ghc-pkg-db}.

\subsection{Tracking file contents\label{sec:file-contents}}

Build systems run actions on files, skipping the actions if the files have not
changed. An important part of that process is determining if a file has
changed. As we saw in~\S\ref{sec:shake_intro}, Make uses modification time to
check outputs are newer than inputs, while Shake uses modification time as a
proxy for file contents and rebuilds on any change. However, there are two
common cases where a file can change modification time without changing its
contents:

\begin{itemize}
\item When generating source code, e.g. C code from a Yacc/Bison parser generator,
most trivial whitespace changes to the parser input will probably result in
identical output.
\item When working on two \lst'git' branches, both of which are based on a
common \lst'master' branch, a typical pattern is to switch from one branch to
another. If the first branch was recently synced with \lst'master', but the
second has not been for a while, the typical workflow is to switch to the second
branch and then merge with \lst'master'. Assuming the differences between the
two branches are small, the number of changed files is also likely to be small.
However, if \lst'master' changes regularly, any files that changed in
\lst'master' since the second branch was last synced will have a new
modification time, despite having the same contents.
\end{itemize}
\noindent
Shake can solve these problems by simply making the value of a file rule reflect the
\emph{contents} of that file, instead of the \emph{modification time}. In the remainder of
this section we discuss how to efficiently implement something approximating
that simple scheme. Since Shake rules are polymorphic it is easy to provide
multiple types of coexisting file rules, although for simplicity we instead
provide the option of which file value type to use as a field of
\lst'ShakeOptions'.

The obvious problem with simply storing the entire contents of all files is that
it will result in a huge Shake database. Instead, we store the result of
applying a hash function to the file contents, where the hash changing indicates
the file contents have changed. There is a remote risk that the file will
change without its hash changing, but unless the build system users are actively
hostile, that is unlikely. The disadvantage of content hashes over modification
times is that hashes are expensive to compute, requiring a full scan of the
file. In particular, after a rule finishes Shake must scan the file it just
built, and on startup Shake must scan all files. Scanning all files can cause
rebuilds where no actions are required to take minutes instead of less than a
second.

As an optimisation, Shake stores the modification time, file size and hash of
the contents. After a rule completes all the information is computed and stored.
When checking if a file has changed, first the modification time is checked, and
if that matches, the contents are assumed to have not changed. If the
modification time has changed, and the file size has also changed, then the file
has definitely changed. Only in the case where the modification time has changed
but the size has not do we compute the actual hash. If that hash is equal to the
previously recorded hash we store a new modification time, so that future checks
will avoid computing the hash. These optimisations give most of the benefits of
storing the file contents, but with significantly reduced costs.

\section{Abstractions\label{sec:abstractions}}

% \begin{itemize}
%   \item Example shared with Background to Shake section
%   \item top-level, starting with main = buildPackage etc.
% \end{itemize}

In the previous section we covered how Shake helps us sidestep the unnecessary
complexities inherent in a large-scale build system. In this section we focus on
the remaining complexities on the way to a successful build system. Before
starting, it is useful to explain our goals. We want the resulting system to be
maintainable, in addition to being fast and correct. The following
aspects are particularly important for maintainability of a large-scale build
system:

\begin{itemize}
\item The code should be simple and direct, talking about concepts familiar to
developers, such as files that are built, tools that are used to build
them, and their configuration settings. These concepts need first-class
representation, not merely strings.
\item The code should permit debugging. There are many obscure configuration
options inherent in any large software project, and the build system is where
such knowledge usually lives. As an example, to include profiling information
when compiling a Haskell source file with GHC we need to pass the \lst'-prof' flag.
We want users to be able to easily determine what flags were used, as well
as why and where specifically that decision was made.
\item The code should permit configuration. Many GHC users work with GHC in
different modes and in different environments. Common configuration settings
include turning on/off documentation, choosing different sets of optimisation flags,
etc.
\end{itemize}

The solution was not obvious to us at first, but we ended up building a DSL for
expressions, and an interpreter that evaluates it to run the build.
% Where the DSL would be unnecessarily complex we opt for a direct
% implementation.
The configuration language is tracked (if it changes the affected build rules
are rerun), has provenance (using the new \lst'?location :: Location' feature in
GHC) and permits easy configuration, for example:

\begin{lstlisting}
builder Ghc ? way profiling ? arg "-prof"
\end{lstlisting}

\noindent The expression adds the \lst'-prof' argument to the command line when
building a file with GHC in the \lst'profiling' way.

\newcommand{\itab}[1]{\hspace{0em}\rlap{#1}}
\newcommand{\tab}[1]{\hspace{.1\textwidth}\rlap{#1}}
\newcommand{\ctab}[1]{\hspace{.031\textwidth}\rlap{#1}}
\newcommand{\ptab}[1]{\hspace{.074\textwidth}\rlap{#1}}
\newcommand{\cotab}[1]{\hspace{.064\textwidth}\rlap{#1}}
\newcommand{\ttab}[1]{\hspace{.058\textwidth}\rlap{#1}}
\newcommand{\tytab}[1]{\hspace{.052\textwidth}\rlap{#1}}
\newcommand{\atab}[1]{\hspace{.102\textwidth}\rlap{#1}}

\begin{figure}
\begin{lstlisting}
#\vspace{-7mm}#
#\line(1,0){240}#
data PackageType = Library | Program#\hspace{15mm}\textbf{\emph{Build types}}#

data Package = Package
#\itab{~~~~\{} \ctab{pkgName} \ptab{:: PackageName}#
#\itab{~~~~,} \ctab{pkgPath} \ptab{:: FilePath}#
#\itab{~~~~,} \ctab{pkgType} \ptab{:: PackageType \}}#

data Stage = Stage0 | Stage1 | Stage2 | Stage3 deriving#\,#Enum

newtype Way = ... deriving Eq

data Context = Context
#\itab{~~~~\{} \ctab{stage} \cotab{:: Stage}#
#\itab{~~~~,} \ctab{package} \cotab{:: Package}#
#\itab{~~~~,} \ctab{way} \cotab{:: Way \}}#

data Builder = Alex
                  | Ar
                  | GenPrimopCode
                  | Ghc Stage
                  | Haddock
                  ... (22 more builders)

data Target = Target
#\itab{~~~~\{} \ctab{context} \ttab{:: Context}#
#\itab{~~~~,} \ctab{builder} \ttab{:: Builder}#
#\itab{~~~~,} \ctab{inputs} \ttab{:: [FilePath]}#
#\itab{~~~~,} \ctab{outputs} \ttab{:: [FilePath] \}}#
#\vspace{-5mm}#
#\line(1,0){240}#
type Expr a = ReaderT Target Action a#\hspace{14mm}\textbf{\emph{Expressions}}#

newtype Diff a = Diff { fromDiff :: a -> a }

type Args = Expr (Diff [String])

append :: [String] -> Args
append as = return $ Diff (<> as)

remove :: [String] -> Args
remove as = return . Diff $ filter (`notElem` as)

arg :: String -> Args
arg = append . return

interpret :: Target -> Args -> Action [String]
interpret target args = do
    diff <- runReaderT args target
    return $ fromDiff diff mempty
#\vspace{-5mm}#
#\line(1,0){240}#
type Predicate = Expr Bool#\hspace{31mm}\textbf{\emph{Predicates}}#

package :: Package -> Predicate
package p = do
    c <- asks context
    return $ p == Context.package c

#\itab{stage} \tytab{:: Stage} \atab{$\rightarrow$ Predicate}#
#\itab{way} \tytab{:: Way} \atab{$\rightarrow$ Predicate}#
#\itab{builder} \tytab{:: Builder} \atab{$\rightarrow$ Predicate}#
#\itab{file} \tytab{:: FilePattern} \atab{$\rightarrow$ Predicate}#

(?) :: Monoid a => Predicate -> Expr a -> Expr a
predicate ? expr = do
    bool <- predicate
    if bool then expr else return mempty
#\vspace{-4mm}#
\end{lstlisting}
\caption{GHC build system abstractions\label{fig:abstractions}}
\end{figure}

\subsection{Programming model}

GHC source code is split into logical units, or \emph{packages}. We model
packages with the \lst'Package' type, see Figure~\ref{fig:abstractions}
(the \emph{Build types} subfigure). A package is identified by a unique
\lst'PackageName' and a \lst'FilePath' pointing to its location in the source
tree. A GHC package can be a library (e.g., \lst'array') or a program (e.g.,
\lst'genprimopcode'), which is captured by \lst'PackageType'. There are 32
libraries and 18 programs (the latter includes the GHC itself and various
utilities).

A package can be built multiple \emph{ways}, for example, to produce a library
with or without profiling information. This is captured by an opaque
type \lst'Way' inhabited by values such as \lst'vanilla' (the simplest
possible way), \lst'profiling' (with profiling information), \lst'debug'
(with debug information), and many others (there are 18 ways in total). Some
ways can be combined, e.g., \lst'debugProfiling'; however, not all combinations
are allowed or currently supported. By making \lst'Way' opaque we make it easier
to add new ways or change their internal representation, something that would be
impossible to achieve in Make, where no information hiding is possible. 

In addition to different build ways, each package can be built by several
versions of GHC, which leads to the notion of \emph{stages}.

In \lst'Stage0' we use the \emph{bootstrap} GHC, i.e. the one that is
installed in the system. During this stage we build \lst'Stage1' GHC, an
intermediate compiler that still lacks many features. It is used during the
following \lst'Stage1' for building a fully-featured \lst'Stage2' GHC, the
primary goal of the build system. We sometimes also build \lst'Stage3' GHC as
a self-test: the object code of \lst'Stage2' and \lst'Stage3' compilers
should be the same.

\lst'Stage', \lst'Package' and \lst'Way' form a GHC-specific
\emph{build context} represented by type \lst'Context'. A typical GHC build
rule, such as \lst'compilePackage', depends on the context as follows: it
uses an appropriate compiler version (e.g., the bootstrap compiler in
\lst'Stage0'), produces object files with different extensions (e.g., vanilla
\lst'*.o' or profiled \lst'*.p_o' object files), puts build artefacts
into an appropriate directory (e.g., \lst'stage1/libraries/base'), etc.
There are $4 \times 40 \times 18 = 2880$ different possible contexts.

A typical build system invokes several build tools, or \emph{builders}, such as
compilers, linkers, archivers, etc., some of which may also be built by the
build system itself. The builders are captured by the \lst'Builder' type. It
is useful to distinguish \emph{internal} and \emph{external} builders, i.e.
those that are build by the build system and those which are installed in the
system, respectively. Function \lst'builderProvenance' returns the stage
during which an internal builder is built, the way it is built, and the package
containing the sources (all captured by a \lst'Context'); \lst'Nothing' is
known about the provenance of external builders.

\begin{lstlisting}
builderProvenance :: Builder -> Maybe Context
builderProvenance = \case
    GenPrimopCode -> Just $
        Context Stage0 genprimopcode vanilla
    Ghc stage ->
        if stage == Stage0 then Nothing
        else Just $ Context (pred stage) ghc vanilla
    Haddock -> Just $
        Context $ Stage2 haddock vanilla
    ...
    _ -> Nothing
\end{lstlisting}

In particular, one can see that \lst'Ghc Stage0' is an external builder,
\lst'Ghc Stage1' is an internal one built from package \lst'ghc'
during \lst'Stage0', \lst'Haddock' is built in \lst'Stage2', etc. There are
27 builders and 16 of them are internal. Furthermore, some builders are
\emph{optional}, e.g., \lst'HsColour', which (if installed) is used to
colourise Haskell code when building documentation.

Each invocation of a builder is fully described by a \lst'Target', which
comprises a build \lst'Context', a \lst'Builder', a list of input and
a list of output files. 3748 targets are built when building \lst'Stage2' GHC
with documentation (with vanilla and profiled libraries). Consider the following
invocation of builder \lst'Alex' as an example:

\begin{lstlisting}
alex -g --latin1 compiler/parser/Lexer.x
                -o compiler/stage1/build/Lexer.hs
\end{lstlisting}

\noindent The corresponding \lst'Target' is:

\begin{lstlisting}
lexerTarget = Target
#\itab{~~~~\{} \ctab{context} \ttab{= Context Stage1 compiler vanilla}#
#\itab{~~~~,} \ctab{builder} \ttab{= Alex}#
#\itab{~~~~,} \ctab{inputs} \ttab{= ["compiler/parser/Lexer.x"]}#
#\itab{~~~~,} \ctab{outputs} \ttab{= ["compiler/stage1/build/Lexer.hs"] \}}#
\end{lstlisting}

\noindent By examining \lst'lexerTarget' it is possible to compute the full
command line for building \lst'compiler/stage1/build/Lexer.hs':
\begin{itemize}
  \item The builder is \lst'Alex'. We lookup the right command
  \lst'alex' in the configuration file \lst'system.config', and use the
  following command line expression: \lst'-g <input> -o <output>'.
  \item The package is \lst'compiler'. We know that we need to add
  flag \lst'--latin1' to the above expression.
  \item We know how to substitute \lst'<input>' and \lst'<output>' in the
  above expression.
  \item We ignore \lst'stage' and \lst'way' because they are not relevant
  in this particular case. However, we record them in the build log.
\end{itemize}

\noindent A build system typically contains many such computations (at least one
for each builder) and it is important to provide a terse and readable notation to
describe them. After experimenting with several abstractions, we converged on
\emph{expressions} defined in the next subsection.

\subsection{Expressions}

An expression \lst'Expr a' is a computation that produces a value of type
\lst'Action a' and can read the current build \lst'Target', as shown in
Figure~\ref{fig:abstractions} (see the \emph{Expressions} subfigure). For example,
the following expression computes command line arguments for invoking \lst'Alex':

\newcommand{\altab}[1]{\hspace{.05\textwidth}\rlap{#1}}

\begin{lstlisting}
alexArgs :: Expr [String]
alexArgs = do
#\itab{~~~~pkg} \altab{$\leftarrow$ asks Target.package}#
#\itab{~~~~src} \altab{$\leftarrow$ asks Target.inputs}#
#\itab{~~~~out} \altab{$\leftarrow$ asks Target.outputs}#
    return $ [ "-g" ]
          #\!#++ [ "--latin1" | pkg == compiler ]
          #\!#++ [ head src ]
          #\!#++ [ "-o", head out ]
\end{lstlisting}

There is a room for improvement of the \lst'alexArgs' expression. For
example, conditional arguments like \lst'--latin1' are very common in build
systems and a better way to express them is clearly desirable. We use Boolean
\emph{predicates} of type \lst'Expr Bool' to achieve this, see
Figure~\ref{fig:abstractions} (the \emph{Predicates} subfigure). In particular, we
use \lst'package :: Package -> Predicate' to check whether a particular package
is currently being built. For example, predicate \lst'package compiler'
returns \lst'True' when the current target belongs to the \lst'compiler'
package.

Operator \lst'(?) :: Monoid a => Predicate -> Expr a -> Expr a' is a
convenient shortcut for applying a predicate to an expression that computes a monoidal value, such
as \lst'[String]'. For example, the following expression returns
\lst'--latin1' when the current target belongs to the compiler package and an
empty expression otherwise:

\begin{lstlisting}
latin1 :: Expr [String]
latin1 = package compiler ? return ["--latin1"]
\end{lstlisting}

\noindent Note, expressions computing monoids themselves form a monoid:

\begin{lstlisting}
instance Monoid a => Monoid (Expr a) where
    mempty #\hspace{1.5mm}#= return mempty
    mappend = liftM2 mappend
\end{lstlisting}

Predicates and monoidal expressions are a powerful combination with many useful
laws that allow to reason about them:
\begin{enumerate}
  \item \itab{Absorption:} \tab{\lst'p ? mempty === mempty'}
  \item \itab{Distributivity:} \tab{\lst'p ? (e <> f) === p ? e <> p ? f'}
  \item \itab{Conjunction:} \tab{\lst'p ? q ? e === (p &&& q) ? e === q ? p ? e'}
  \item \itab{Disjunction:} \tab{if \lst'p &&& q === False' then} \vspace{1mm}\\
  \lst'    p ? e <> q ? e === (p ||| q) ? e === q ? e <> p ? e'
  \item \itab{Complement:} \tab{\lst'p ? e <> !!!p ? e === e'}
\end{enumerate}

All expressions need to be modifiable by users of the build system. We therefore
need to provide a way not only to add new arguments to an expression, but also
to modify and remove them. A simple way to achieve this is to switch to difference
list expressions, represented by type \lst'Expr (Diff a)', which is used to
construct values of type \lst'Diff a' with the following monoid instance:

\begin{lstlisting}
instance Monoid (Diff a) where
    mempty #\hspace{24mm}#= Diff id
    mappend (Diff x) (Diff y) = Diff $ y . x
\end{lstlisting}

\noindent The reverse order of function composition \lst'y . x' ensures that
when two \lst'Expr (Diff a)' computations are combined \lst'c1 <> c2', then
\lst'c1' is applied first and \lst'c2' is applied second.

The following functions can be used to append and remove items to/from a
difference list:

\begin{lstlisting}
append :: Monoid a => a -> Expr (Diff a)
append x = return $ Diff (<> x)

remove :: Eq a => [a] -> Expr (Diff [a])
remove xs = return . Diff $ filter (`notElem` xs)
\end{lstlisting}

\newcommand{\tabx}[1]{\hspace{.106\textwidth}\rlap{#1}}
\newcommand{\taby}[1]{\hspace{.103\textwidth}\rlap{#1}}
\newcommand{\tabz}[1]{\hspace{.24\textwidth}\rlap{#1}}

\begin{figure}
\begin{lstlisting}
#\vspace{-7mm}#
#\line(1,0){240}#
#\itab{data Stage} \tabx{= Stage0} \taby{| Stage1}\hspace{29mm}\textbf{\emph{Build~types}}#
#\itab{data Package} \tabx{= Array} \taby{| Base}#
#\itab{data Way} \tabx{= Vanilla} \taby{| Profiling}#
#\itab{data Builder} \tabx{= Ghc Stage} \taby{| Ar}#
#\vspace{-5mm}#
#\line(1,0){240}#
ghcArgs, arArgs, userArgs, allArgs :: Args#\hspace{7.8mm}\textbf{\emph{Command~line}}#
ghcArgs = builder Ghc ? mconcat#\hspace{23.3mm}\textbf{\emph{arguments}}#
    [ arg "-O2"
    , way Profiling ? arg "-prof"
    , file "//base/GHC/IO.*" ? arg "-funbox-strict-fields" 
    , arg "-c", arg =<< getInput 
    , arg "-o", arg =<< getOutput ]

arArgs = builder Ar ? mconcat
    [ arg "q"
    , arg =<< getOutput
    , append =<< getInputs ]

userArgs = package Array ? arg "-Wall"

allArgs = ghcArgs <> arArgs <> userArgs
#\vspace{-5mm}#
#\line(1,0){240}#
build :: Target -> Action ()#\hspace{32mm}\textbf{\emph{Build rules}}#
build target@Target {..} = do
    path <- builderPath builder
    args #\,#<- interpret target allArgs
    need [path]
    cmd [path] args

path :: Context -> FilePath
path context@Context#\,#{..} = show#\,#stage </> pkgName#\,#package

#\itab{osuf :: Way $\rightarrow$ String} \tabz{asuf :: Way $\rightarrow$ String}#
#\itab{osuf Vanilla~~~= ".o"} \tabz{asuf Vanilla~~~= ".a"}#
#\itab{osuf Profiling = ".p\_o"} \tabz{asuf Profiling = "\_p.a"}#

lookupDependencies :: Context#\,#->#\,#FilePath#\,#->#\,#Action#\,#[FilePath]

lookupSources :: Context -> Action [FilePath]

compilePackage :: Context -> Rules ()
compilePackage context@Context {..} = 
    path context </> "*" ++ osuf way %> \obj -> do
        let src = obj -<.> "hs"
        deps <- lookupDependencies context obj
        need $ src : deps
        build $ Target context (Ghc stage) [src] [obj]

buildPackageLibrary :: Context -> Rules ()
buildPackageLibrary context@Context {..} = 
    path context </> "*" ++ asuf way %> \a -> do
        srcs <- lookupSources context
        let objs = [ src -<.> osuf way | src <- srcs ]
        need objs
        build $ Target context Ar objs [a]
#\vspace{-5mm}#
#\line(1,0){240}#
main :: IO ()#\hspace{59.5mm}\textbf{\emph{Main}}#
main = shake shakeOptions $ do
    let contexts = Context <$> 
        [Stage0,#\,#Stage1]#\,#<*>#\,#[Array,#\,#Base]#\,#<*>#\,#[Vanilla,#\,#Profiling]
  
    want [#\,#path#\,#c </> "HSlib" ++ asuf#\,#(way#\,#c) | c <- contexts#\,#]

    traverse_ compilePackage      #\hspace{0.2mm}#contexts
    traverse_ buildPackageLibrary contexts
#\vspace{-4mm}#
\end{lstlisting}

\caption{Example of a build system\label{fig:example-abstractions}}
\end{figure}
We are now ready to introduce \lst'Args', a type of expressions for
constructing command line arguments in the build system. In addition to the
above generic functions (whose specialised versions are shown in
Figure~\ref{fig:abstractions}), it is equipped with function
\lst'arg :: String -> Args' for injecting simple \lst'String' arguments into
\lst'Args'. With these abstractions in place, we can construct command line
arguments for \lst'Alex' as follows:

\begin{lstlisting}
alexArgs :: Args
alexArgs = mconcat [ arg "-g"
#\hspace{28.8mm}#, package compiler ? arg "--latin1"
#\hspace{28.8mm}#, arg =<< getInput
#\hspace{28.8mm}#, arg "-o", arg =<< getOutput ]
\end{lstlisting}

\noindent Here \lst'getInput :: Expr FilePath' and
\lst'getOutput :: Expr FilePath' are expressions that check that
\lst'Target.inputs' and \lst'Target.outputs' contain exactly one element and
return it.

The resulting \lst'alexArgs' expression is terse and readable. All
distracting plumbing details have been abstracted away so that the designers and
users of the build system could focus on what matters. \todo{Also mention
Packages and Ways expressions.}

We compose all command line arguments into \lst'allArgs :: Args' expression,
applying custom user modifications \lst'userArgs' in the very end, hence
allowing the user to override any default setting:

\begin{lstlisting}
allArgs :: Args
allArgs = mconcat [ builder Alex ? alexArgs, ..., userArgs ]
\end{lstlisting}

The resulting expression is used in the \lst'build' function that is responsible
for building a given \lst'Target':

\begin{lstlisting}
build :: Target -> Action ()
build target@Target {..} = do
    path <- builderPath builder
    args #\,#<- interpret target allArgs
    need [path]
    checkArgsHash target
    cmd [path] args
\end{lstlisting}

\noindent We clarify each statement of the \lst'build' function below:
\begin{itemize}
  \item Firstly, \lst'builderPath :: Builder -> Action FilePath' determines the
  path to the builder depending on its provenance and the contents of the
  \lst'system.config' file.
  \item We \lst'interpret' the \lst'allArgs' expression w.r.t. to the
  \lst'target', and obtain the list of \lst'String' arguments to be passed to
  the builder. See Figure~\ref{fig:abstractions} for the implementation of
  \lst'interpret'.
  \item We \lst'need' the builder to make sure it is up-to-date. Some builders
  are built by the build system, e.g. \lst'genprimopcode',
  \lst'ghc-cabal', stage1 GHC, so it is important to rebuild them (as well as
  all dependent targets) if need be.
  \item Function \lst'checkArgsHash :: Target -> Action ()' checks whether the
  \lst'target' needs to be rebuilt because the command line computed from
  \lst'allArgs' expression has changed since the previous build. If it changed,
  the target is rebuilt even if all its dependencies are up-to-date. This tracks
  changes both in the environment and in the build system itself.
  \todo{\textbf{Andrey}: Explain how checkArgsHash works?}
  \item Finally, we invoke the builder with appropriate arguments using Shake's
  \lst'cmd' function.
\end{itemize}

\subsection{A simple build system example}

Figure~\ref{fig:example-abstractions} shows a simple build system that uses the
abstractions introduced in this section.

\todo{\textbf{Andrey}: Add description of the example (0.5 columns).}

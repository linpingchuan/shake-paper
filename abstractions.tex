\section{Useful abstractions\label{sec:abstractions}}

\begin{itemize}
  \item Example shared with Background to Shake section
  \item top-level, starting with main = buildPackage etc.
\end{itemize}

In the previous section we covered how we neatly sidestep the unnecessary
complexities inherent in a large scale build system. In this section we focus on
the remaining complexities, how to engineer a successful build system. Before
starting, it is useful to explain our goals. We want the resulting system to be
maintainable, in addition to being fast and correct. For maintainability on such
a large system there are really several aspects:

\begin{itemize}
\item The code should be simple and direct, talking about concepts familiar to developers. In particular that means files that are produced, configuration settings and tools that are used to produce them. These concepts need first-class representation, not merely strings.
\item The code should permit debugging. There are lots of obscure configuration operations inherent in any large system, and the build system is the place where such knowledge should live. As an example, when running the Alex program over one particular file we need to pass the \texttt{--latin1} flag. We want users to be able to determine what flags were used and where specifically that decision was made.
\item The code should permit configuration. Many GHC users work with GHC in different modes. Turning on/off documentation, different packages of optimisation flags etc.
\end{itemize}

The solution was not obvious to us at first, but we ended up building a DSL for expressions, and an interpreter that evaluates it to run the build. Where the DSL would be unnecessarily complex we opt for a direct implementation. The configuration language is tracked (if it changes the necessary bits rebuild), has provenance (using the new Location feature in GHC) and permits easy configuration. As an example of the configuration:

\begin{verbatim}
package compiler ?
    builder Alex ? arg "--latin1"
\end{verbatim}

\subsection{Abstracting over patterns of dependencies}

\todo{Shall we move this to the previous section?}

By embedding the build system in Haskell we get access to its rich abstraction
facilities. Examples:
\begin{itemize}
  \item Use general predicates instead of file patterns. For example, several
  files are built by calling \texttt{genprimopcode}, which can be captured by a
  single build OR-rule:
  
\begin{lstlisting}[basicstyle=\ttfamily]
[ "autogen/GHC/Prim.hs"
, "GHC/PrimopWrappers.hs"
, "*.hs-incl" ] |%> \file -> do ...
\end{lstlisting}
  
  \item Build rules with multiple outputs (AND-rules)
  \item Compute build arguments from target filename
\end{itemize}

\begin{figure}
\begin{lstlisting}[basicstyle=\ttfamily]
data PackageType = Program | Library

data Package = Package
    { pkgName :: PackageName
    , pkgPath :: FilePath
    , pkgType :: PackageType }

newtype Way = ... deriving Eq

data Stage = Stage0 | Stage1 | Stage2 | Stage3
    deriving Enum
   
data Context = Context
    { stage   :: Stage
    , package :: Package
    , way     :: Way }

data Builder = Alex
             | Ar
             | GenPrimopCode
             | Ghc Stage
             | Haddock
             ... (22 more builders)

data Target = Target
    { context :: Context
    , builder :: Builder
    , inputs  :: [FilePath]
    , outputs :: [FilePath] }

type Expr a = ReaderT Target Action a

newtype Diff a = Diff { fromDiff :: a -> a }

type DiffExpr a = Expr (Diff a)

type Args     = DiffExpr [String]
type Packages = DiffExpr [Package]
type Ways     = DiffExpr [Way]
\end{lstlisting}
\caption{GHC build system abstractions\label{fig:abstractions}}
\end{figure}

\subsection{Programming model}

Source code is typically split into logical units, or \emph{packages},
and GHC is no exception. We model packages with the \texttt{Package}
type, see Fig.~\ref{fig:abstractions}. A package is identified by a unique
\texttt{PackageName} and a \texttt{FilePath} pointing to its location in the
source tree. A GHC package can be a program (e.g., \texttt{genprimopcode}) or a
library (e.g., \texttt{array}), which is captured by \texttt{PackageType}.

A package can be built multiple \emph{ways}, for example, to produce a library
with or without profiling information. This is captured by an opaque
type \texttt{Way} inhabited by values such as \texttt{vanilla} (the simplest
possible way), \texttt{profiling} (with profiling information), \texttt{debug} (with
debug information), and many others. Some ways can be combined, e.g.,
\texttt{debugProfiling}; however, not all combinations are allowed or currently
supported. By making \texttt{Way} opaque we make it easier to add new ways
or change their internal representation, something that would be
impossible to achieve in \make{}, where no information hiding is
possible.
 
In addition to different build ways, each package can be built by several
versions of GHC, which leads to the notion of \emph{stages}.

In \texttt{Stage0} we use the \emph{bootstrap} GHC, i.e. the one that is
installed in the system. During this stage we build \texttt{Stage1} GHC, an
intermediate compiler that still lacks many features. It is used during the
following \texttt{Stage1} for building a fully-featured \texttt{Stage2} GHC, the
primary goal of the build system. We sometimes also build \texttt{Stage3} GHC as
a self-test: the object code of \texttt{Stage2} and \texttt{Stage3} compilers
should be the same.

\texttt{Stage}, \texttt{Package}, and \texttt{Way} form a GHC-specific
\emph{build context} represented by type \texttt{Context}. A typical GHC build
rule, such as \texttt{compilePackage}, depends on the context as follows: it
uses an appropriate compiler version (e.g., the bootstrap compiler in
\texttt{Stage0}), produces object files with different extensions (e.g.,
vanilla \texttt{"*.o"} or profiled \texttt{"*.p\_o"} object files), puts build
artefacts into an appropriate directory (e.g.,
\texttt{"stage1/libraries/base"}), etc.

A typical build system invokes several build tools, or \emph{builders}, such as
compilers, linkers, archivers, etc., some of which may also be built by the
build system itself. The builders are captured by the \texttt{Builder} type. It
is useful to distinguish \emph{internal} and \emph{external} builders, i.e.
those that are build by the build system and those which are installed in the
system, respectively. Function \texttt{builderProvenance} returns the stage
during which an internal builder is built, the way it is built, and the package
containing the sources (all captured by a \texttt{Context}); \texttt{Nothing} is
known about the provenance of external builders.

\begin{lstlisting}[basicstyle=\ttfamily]
builderProvenance :: Builder -> Maybe Context
builderProvenance = \case
    GenPrimopCode -> Just $
        Context Stage0 genprimopcode vanilla
    Ghc stage ->
        if stage == Stage0 then Nothing
        else Just $ Context (pred stage) ghc vanilla
    Haddock -> Just $
        Context $ Stage2 haddock vanilla
    ...
    _ -> Nothing
\end{lstlisting}

In particular, one can see that \texttt{Ghc Stage0} is an external builder,
\texttt{Ghc Stage1} is an internal one built from package \texttt{ghc}
during \texttt{Stage0}, etc.

Each invocation of a builder is fully described by a \texttt{Target}, which
comprises a build \texttt{Context}, a \texttt{Builder}, a list of input and
a list of output files. For example, consider the following invocation of
builder \texttt{Alex}:

\begin{verbatim}
alex -g --latin1 compiler/parser/Lexer.x
              -o compiler/stage1/build/Lexer.hs
\end{verbatim}

\noindent The corresponding \texttt{Target} is:

\begin{lstlisting}[basicstyle=\ttfamily]
lexerTarget = Target
    { context = Context Stage1 compiler vanilla
    , builder = Alex
    , inputs  = ["compiler/parser/Lexer.x"]
    , outputs = ["compiler/stage1/build/Lexer.hs"] }
\end{lstlisting}

By examining \texttt{lexerTarget} it is possible to compute the full command
line for building \texttt{compiler/stage1/build/Lexer.hs}:
\begin{itemize}
  \item The builder is \texttt{Alex}. We lookup the right command
  \texttt{alex} in the configuration file \texttt{system.config}, and use the
  following command line expression: \texttt{-g <input> -o <output>}.
  \item The package is \texttt{compiler}. We know that we need to add
  flag \texttt{--latin1} to the above expression.
  \item We know how to substitute \texttt{<input>} and \texttt{<output>} in the
  above expression.
  \item We ignore \texttt{stage} and \texttt{way} because they are not relevant
  in this particular case. However, we record them in the build log.
\end{itemize}

A build system typically contains many such computations (at least one for each
builder) and it is important to provide a terse and readable notation to
describe them. After experimenting with several abstractions, we converged on
\emph{expressions} defined in the next subsection.

\subsection{Expressions}

An expression \texttt{Expr a} is a computation that produces a value of type
\texttt{Action a} and can read the current build \texttt{Target}. For example,
the following expression computes command line arguments for invoking
\texttt{Alex}:

\begin{lstlisting}[basicstyle=\ttfamily]
alexArgs :: Expr [String]
alexArgs = do
    pkg <- asks Target.package
    src <- asks Target.inputs
    out <- asks Target.outputs
    return $ [ "-g" ]
          ++ [ "--latin1" | pkg == compiler ]
          ++ [ head src ]
          ++ [ "-o", head out ]
\end{lstlisting}

% \noindent Here \texttt{builderPath :: Builder -> Action FilePath} determines the
% path to a builder depending on its provenance and the contents of
% \texttt{system.config} file.

There is a room for improvement of the \texttt{alexArgs} expression. For
example, conditional flags like \texttt{--latin1} are very common in build
systems and a better way to express them is clearly desirable. We use Boolean
\emph{predicates} to achieve this:

\begin{lstlisting}[basicstyle=\ttfamily]
package :: Package -> Predicate
package p = do
    context <- asks Target.context
    return $ p == Context.package context

(?) :: Monoid a => Predicate -> Expr a -> Expr a
predicate ? expr = do
    bool <- predicate
    if bool then expr else return mempty
\end{lstlisting}

We can now use \texttt{package} to check whether a particular package is
currently being built, e.g., predicate \texttt{package compiler} returns
\texttt{True} when the current target belongs to the compiler package.
Operator \texttt{?} provides a convenient shortcut for applying a predicate
to an expression that computes a monoidal value, such as \texttt{[String]}. For
example, the following expression returns \texttt{--latin1} when the current
target belongs to the compiler package and an empty expression otherwise:

\begin{lstlisting}[basicstyle=\ttfamily]
latin1 :: Expr [String]
latin1 = package compiler ? return ["--latin1"]
\end{lstlisting}

\noindent Note, expressions computing monoids themselves form a monoid:

\begin{lstlisting}[basicstyle=\ttfamily]
instance Monoid a => Monoid (Expr a) where
    mempty  = return mempty
    mappend = liftM2 mappend
\end{lstlisting}

\newcommand{\itab}[1]{\hspace{0em}\rlap{#1}}
\newcommand{\tab}[1]{\hspace{.12\textwidth}\rlap{#1}}

Predicates and monoidal expressions are a powerful combination with many useful
laws that allow to reason about them:
\begin{enumerate}
  \item \itab{Absorption:} \tab{\texttt{p ? mempty \ \ \ \ \ == mempty}}
  \item \itab{Distributivity:} \tab{\texttt{p ? (e <> f) \ \ \ == p ? e <> p ? f}}
  \item \itab{Conjunction:} \tab{\texttt{p ? q ? e \ \ \ \ \ \ == (p $\wedge$ q) ? e}}
  \item \itab{Complement:} \tab{\texttt{p ? e <> $\!\neg$p ? e == e}}
  \item \itab{Reordering:} \tab{\texttt{p ? e <> $\!\neg$p ? f  == $\neg$p ? f <> p ? e}}
\end{enumerate}

\todo{The above is true only for certain well-behaved predicates: need
termination and no observable effects? }

All expressions need to be modifiable by users of the build system. We therefore
need to provide a way not only to add new flags to an expression, but also to
modify and remove them. A simple way to achieve this is to switch to difference
list expressions, represented by type \texttt{DiffExpr a}, which is used to
construct values of type \texttt{Diff a} with the following monoid instance:

\begin{lstlisting}[basicstyle=\ttfamily]
instance Monoid (Diff a) where
    mempty = Diff id
    Diff x `mappend` Diff y = Diff $ y . x
\end{lstlisting}

The reverse order of function composition \texttt{y . x} ensures that when two
\texttt{DiffExpr a} computations are combined \texttt{c1 <> c2}, then
\texttt{c1} is applied first and \texttt{c2} is applied second.

The following functions can be used to append and remove items to/from a
difference list:

\begin{lstlisting}[basicstyle=\ttfamily]
append :: Monoid a => a -> DiffExpr a
append x = return $ Diff (<> x)

remove :: Eq a => [a] -> DiffExpr [a]
remove xs = return $ Diff $ filter (`notElem` xs)
\end{lstlisting}

We are now ready to introduce \texttt{Args}, a type of expressions for
constructing command line arguments in the build system. In addition to the
above generic functions, it is equipped with function \texttt{arg} for injecting
simple \texttt{String} arguments into \texttt{Args}:

\begin{lstlisting}[basicstyle=\ttfamily]
arg :: String -> Args
arg = append . return
\end{lstlisting}

With the above abstractions in place, we can construct command line arguments
for \texttt{Alex} as follows:

\begin{lstlisting}[basicstyle=\ttfamily]
alexArgs :: Args
alexArgs = mconcat [ arg "-g"
                   , package compiler ? arg "--latin1" 
                   , arg =<< getInput
                   , arg "-o", arg =<< getOutput ]
\end{lstlisting}

Here \texttt{getInput} and \texttt{getOutput} are expressions that check that
\texttt{Target.inputs} and \texttt{Target.outputs} contain exactly one value and
return it.

The resulting \texttt{alexArgs} expression is terse and readable. All
distracting plumbing details have been abstracted away so that the
designers and users of the build system could focus on what matters.

\noindent ----\\
\noindent The \texttt{build} function takes care of building a single
\texttt{Target}:
\begin{itemize}
  \item It computes the complete command line to build the target from the
  \texttt{Args} expression.
  \item If the command line has changed since the last invocation of the build
  system, the target is rebuilt even if all its dependencies are up-to-date.
  This tracks changes both in the environment and in the build system itself.
  \item It makes sure the required builder is up-to-date. Some builders are
  built by the build system, e.g. \texttt{genprimopcode}, \texttt{ghc-cabal},
  stage1 GHC, so it is important to rebuild them if need be.
  \item Finally, it runs the builder to build the target, printing diagnostic
  information if need be.
\end{itemize}

\noindent ----\\
\noindent Example of a micro build system.

\begin{figure}
\begin{lstlisting}[basicstyle=\ttfamily]

rules :: Rules ()
rules = do
    for_ [Stage0, Stage1] $ \stage ->
        for_ [array, base] $ \pkg ->
            for_ [vanilla, profiling] $ \way -> do
                let context = Context stage pkg way
                compilePackage context
                buildPackageLibrary context

osuf :: Way -> String
osuf vanilla   = ".o"
osuf profiling = ".p_o"

asuf :: Way -> String
asuf vanilla   = ".a"
asuf profiling = "_p.a"

compilePackage :: Context -> Rules ()
compilePackage context @ Context {..} = do
    let path = show stage </> pkgName package

    path </> "*" ++ osuf way %> \obj -> do
        let src = obj -<.> "hs"
        deps <- lookupDependencies context obj
        need $ src : deps
        build $ Target context (Ghc stage) [src] [obj]

buildPackageLibrary :: Context -> Rules ()
buildPackageLibrary context @ Context {..} = do
    let path    = show stage </> pkgName package
        obj src = path </> src -<.> osuf way

    path </> "*" ++ asuf way %> \a -> do
        srcs <- lookupSources context
        let objs = map obj srcs
        need objs
        build $ Target context Ar objs [a]
                
ghcArgs :: Args
ghcArgs = builder Ghc ? mconcat
    [ arg "-O2"
    , way profiling ? arg "-prof"
    , arg "-c", arg =<< getInput
    , arg "-o", arg =<< getOutput ]
    
arArgs :: Args
arArgs = builder Ar ? mconcat
    [ arg "q"
    , arg =<< getOutput
    , append =<< getInputs ]

userArgs :: Args
userArgs = builder Ghc ? arg "-Wall"

allArgs :: Args
allArgs = ghcArgs <> arArgs <> userArgs

build :: Target -> Action ()
build target @ Target {..} = do
    path <- builderPath context
    args <- runReaderT allArgs target
    cmd [path] args
\end{lstlisting}
\caption{Example of a build system\label{fig:example-abstractions}}
\end{figure}

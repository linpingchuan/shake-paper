\section{Useful abstractions\label{sec:abstractions}}

In the previous section we covered how we neatly sidestep the unnecessary complexities inherent in a large scale build system. In this section we focus on the remaining complexities, how to engineer a successful build system. Before starting, it is useful to explain our goals. We want the resulting system to be maintainable, in addition to being fast and correct. For maintainability on such a large system there are really several aspects:

\begin{itemize}
\item The code should be simple and direct, talking about concepts familiar to developers. In particular that means files that are produced, configuration settings and tools that are used to produce them. These concepts need first-class representation, not merely strings.
\item The code should permit debugging. There are lots of obscure configuration operations inherent in any large system, and the build system is the place where such knowledge should live. As an example, when running the Alex program over one particular file we need to pass the \texttt{--latin1} flag. We want users to be able to determine what flags were used and where specifically that decision was made.
\item The code should permit configuration. Many GHC users work with GHC in different modes. Turning on/off documentation, different packages of optimisation flags etc.
\end{itemize}

The solution was not obvious to us at first, but we ended up building a DSL for expressions, and an interpreter that evaluates it to run the build. Where the DSL would be unnecessarily complex we opt for a direct implementation. The configuration language is tracked (if it changes the necessary bits rebuild), has provenance (using the new Location feature in GHC) and permits easy configuration. As an example of the configuration:

\begin{verbatim}
package compiler ?
    builder Alex ? arg "--latin1"
\end{verbatim}



\subsection{Abstracting over patterns of dependencies}



By embedding the build system in Haskell we get access to its rich abstraction
facilities. Examples:
\begin{itemize}
  \item Use predicates instead of file patterns (a special case: OR-rules)
  \item Build rules with multiple outputs (AND-rules)
  \item Compute build arguments from target filename
\end{itemize}

\subsection{Programming model}

Review of the datatypes we use: \texttt{Builder}, \texttt{Package},
\texttt{Target}, \texttt{Expression}.

~\\
\noindent The \texttt{build} function takes care of building a single
\texttt{Target}:
\begin{itemize}
  \item It computes the complete command line to build the target from the
  \texttt{Args} expression.
  \item If the command line has changed since the last invocation of the build
  system, the target is rebuilt even if all its dependencies are up-to-date.
  This tracks changes both in the environment and in the build system itself.
  \item It makes sure the required builder is up-to-date. Some builders are
  built by the build system, e.g. \texttt{genprimopcode}, \texttt{ghc-cabal},
  stage1 GHC, so it is important to rebuild them if need be.
  \item Finally, it runs the builder to build the target, printing diagnostic
  information if need be.
\end{itemize}

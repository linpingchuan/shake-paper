\section{Useful abstractions\label{sec:abstractions}}

In the previous section we covered how we neatly sidestep the unnecessary complexities inherent in a large scale build system. In this section we focus on the remaining complexities, how to engineer a successful build system. Before starting, it is useful to explain our goals. We want the resulting system to be maintainable, in addition to being fast and correct. For maintainability on such a large system there are really several aspects:

\begin{itemize}
\item The code should be simple and direct, talking about concepts familiar to developers. In particular that means files that are produced, configuration settings and tools that are used to produce them. These concepts need first-class representation, not merely strings.
\item The code should permit debugging. There are lots of obscure configuration operations inherent in any large system, and the build system is the place where such knowledge should live. As an example, when running the Alex program over one particular file we need to pass the \texttt{--latin1} flag. We want users to be able to determine what flags were used and where specifically that decision was made.
\item The code should permit configuration. Many GHC users work with GHC in different modes. Turning on/off documentation, different packages of optimisation flags etc.
\end{itemize}

The solution was not obvious to us at first, but we ended up building a DSL for expressions, and an interpreter that evaluates it to run the build. Where the DSL would be unnecessarily complex we opt for a direct implementation. The configuration language is tracked (if it changes the necessary bits rebuild), has provenance (using the new Location feature in GHC) and permits easy configuration. As an example of the configuration:

\begin{verbatim}
package compiler ?
    builder Alex ? arg "--latin1"
\end{verbatim}



\subsection{Abstracting over patterns of dependencies}

\todo{Shall we move this to the previous section?}

By embedding the build system in Haskell we get access to its rich abstraction
facilities. Examples:
\begin{itemize}
  \item Use general predicates instead of file patterns. For example, several
  files are built by calling \texttt{genprimopcode}, which can be captured by a
  single build OR-rule:
  
\begin{lstlisting}[basicstyle=\ttfamily]
[ "autogen/GHC/Prim.hs"
, "GHC/PrimopWrappers.hs"
, "*.hs-incl" ] |%> \file -> do ...
\end{lstlisting}
  
  \item Build rules with multiple outputs (AND-rules)
  \item Compute build arguments from target filename
\end{itemize}

\subsection{Programming model}

Review of the datatypes we use: \texttt{Stage}, \texttt{Builder}, 
\texttt{Package}, \texttt{Target}, \texttt{Expression}.

\todo{It is important to emphasise that the following abstractions are common
for build systems.}

Source code is typically split into logical units, or \emph{packages},
and GHC is no exception. We model packages with the \texttt{Package}
type:

\begin{lstlisting}[basicstyle=\ttfamily]
data Package = Package
    { pkgName :: PackageName
    , pkgPath :: FilePath
    , pkgType :: PackageType }
\end{lstlisting}

A package is identified by a unique \texttt{PackageName} and a
\texttt{FilePath} pointing to its location in the source tree. A GHC package can
be a program (e.g., \texttt{genprimopcode}) or a library (e.g., \texttt{array}), which is
captured by \texttt{PackageType}:

\begin{lstlisting}[basicstyle=\ttfamily]
data PackageType = Program | Library
\end{lstlisting}

A package can be built multiple \emph{ways}, for example, to produce a library
with or without profiling information. This is captured by an opaque
type \texttt{Way} inhabited by values such as \texttt{vanilla} (the simplest
possible way), \texttt{profiling} (with profiling information), \texttt{debug} (with
debug information), and many others. Some ways can be combined, e.g.,
\texttt{debugProfiling}; however, not all combinations are allowed or currently
supported. By making \texttt{Way} opaque we make it easier to add new ways
or change their internal representation, something that would be
impossible to achieve in \make{}, where no information hiding is
possible.
 
In addition to different build ways, each package can be built by several
versions of GHC, which leads to the notion of \emph{stages}:

\begin{lstlisting}[basicstyle=\ttfamily]
data Stage = Stage0 | Stage1 | Stage2 | Stage3
    deriving Enum
\end{lstlisting}

In \texttt{Stage0} we use the \emph{bootstrap} GHC, i.e. the one that is
installed in the system. During this stage we build \texttt{Stage1} GHC, an
intermediate compiler that still lacks many features. It is used during the
following \texttt{Stage1} for building a fully-featured \texttt{Stage2} GHC, the
primary goal of the build system. We sometimes also build \texttt{Stage3} GHC as
a self-test: the object code of \texttt{Stage2} and \texttt{Stage3} compilers
should be the same.

A typical build system invokes several build tools, or \emph{builders}, such as
compilers, linkers, archivers, etc., some of which may also be built by the
build system itself. The builders are captured by the \texttt{Builder} type
(only 5 out of all 27 constructors are shown):

\begin{lstlisting}[basicstyle=\ttfamily]
data Builder = Alex
             | Ar
             | GenPrimopCode
             | Ghc Stage
             | Haddock
             ...
\end{lstlisting}

It is useful to distinguish \emph{internal} and \emph{external} builders, i.e.
those that are build by the build system and those which are installed in the
system, respectively. Function \texttt{builderProvenance} returns the stage
during which an internal builder is built and the package containing the
sources; \texttt{Nothing} is known about the provenance of external builders.

\begin{lstlisting}[basicstyle=\ttfamily]
builderProvenance :: Builder -> Maybe (Stage, Package)
builderProvenance = \case
    GenPrimopCode -> Just (Stage0, genprimopcode)
    Ghc stage     -> if stage == Stage0
                     then Nothing
                     else Just (pred stage, ghc)
    Haddock       -> Just (Stage2, haddock)
    ...
    _             -> Nothing
\end{lstlisting}

In particular, one can see that \texttt{Ghc Stage0} is an external builder,
\texttt{Ghc Stage1} is an internal one built from package \texttt{ghc}
during \texttt{Stage0}, etc.

Each invocation of a builder is fully described by a \texttt{Target}:

\begin{lstlisting}[basicstyle=\ttfamily]
data Target = Target
    { stage   :: Stage
    , package :: Package
    , builder :: Builder
    , way     :: Way
    , inputs  :: [FilePath]
    , outputs :: [FilePath] }
\end{lstlisting}

\noindent For example, consider the following invocation of \texttt{Alex}:

\begin{verbatim}
alex -g --latin1 compiler/parser/Lexer.x
              -o compiler/stage1/build/Lexer.hs
\end{verbatim}

\noindent The corresponding \texttt{Target} is:

\begin{lstlisting}[basicstyle=\ttfamily]
lexerTarget = Target
    { stage   = Stage1
    , package = compiler
    , builder = Alex
    , way     = vanilla
    , inputs  = ["compiler/parser/Lexer.x"]
    , outputs = ["compiler/stage1/build/Lexer.hs"] }
\end{lstlisting}

By examining \texttt{lexerTarget} it is possible to compute the full command
line for building \texttt{compiler/stage1/build/Lexer.hs}:
\begin{itemize}
  \item The builder is \texttt{Alex}. We lookup the right command
  \texttt{alex} in the configuration file \texttt{system.config}, and use the
  following command line expression: \texttt{-g <input> -o <output>}.
  \item The package is \texttt{compiler}. We know that we need to add
  flag \texttt{--latin1} to the above expression.
  \item We know how to substitute \texttt{<input>} and \texttt{<output>} in the
  above expression.
  \item We ignore \texttt{stage} and \texttt{way} because they are not relevant
  in this particular case. However, we record them in the build log.
\end{itemize}

A build system typically contains many such computations (at least one for each
builder) and it is important to provide a terse and readable notation to
describe them. After experimenting with several abstractions, we converged on
\emph{expressions} defined in the next subsection.

\subsection{Expressions}

An expression \texttt{Expr a} is a computation that produces a value of type
\texttt{Action a} and can read the current build \texttt{Target}:

\begin{lstlisting}[basicstyle=\ttfamily]
type Expr a = ReaderT Target Action a
\end{lstlisting}

For example, the following expression computes the full command line for
invoking \texttt{Alex}:

\begin{lstlisting}[basicstyle=\ttfamily]
alexCmdLine :: Expr [String]
alexCmdLine = do
    bld <- asks Target.builder
    pkg <- asks Target.package
    src <- asks Target.inputs
    out <- asks Target.outputs
    cmd <- lift $ builderPath bld
    return $ [ cmd ]
        ++ [ "-g" ]
        ++ [ "--latin1" | pkg == compiler ]
        ++ [ head src ]
        ++ [ "-o", head out ]
\end{lstlisting}

\noindent Here \texttt{builderPath :: Builder -> Action FilePath} determines the
path to a builder depending on its provenance and the contents of
\texttt{system.config} file.

There is a room for improvement of the \texttt{alexCmdLine} expression. For
example, conditional flags like \texttt{--latin1} are very common in build
systems and a better way to express them is clearly desirable. We use Boolean
\emph{predicates} to achieve this:

\begin{lstlisting}[basicstyle=\ttfamily]
type Predicate = Expr Bool

package :: Package -> Predicate
package p = (p ==) <$> asks Target.package

(?) :: Monoid a => Predicate -> Expr a -> Expr a
predicate ? expr = do
    bool <- predicate
    if bool then expr else return mempty
\end{lstlisting}

We can now use \texttt{package} to check whether a particular package is
currently being built, e.g., predicate \texttt{package compiler} returns
\texttt{True} when the current target belongs to the compiler package.
Operator \texttt{?} provides a convenient shortcut for applying a predicate
to an expression that computes a monoidal value, such as \texttt{[String]}. For
example, the following expression returns \texttt{--latin1} when the current
target belongs to the compiler package and an empty expression otherwise:

\begin{lstlisting}[basicstyle=\ttfamily]
latin1 :: Expr [String]
latin1 = package compiler ? return ["--latin1"]
\end{lstlisting}

\noindent Note, expressions computing monoids themselves form a monoid:

\begin{lstlisting}[basicstyle=\ttfamily]
instance Monoid a => Monoid (Expr a) where
    mempty  = return mempty
    mappend = liftM2 mappend
\end{lstlisting}

\newcommand{\itab}[1]{\hspace{0em}\rlap{#1}}
\newcommand{\tab}[1]{\hspace{.12\textwidth}\rlap{#1}}

Predicates and monoidal expressions are a powerful combination with many useful
laws that allow to reason about them:
\begin{enumerate}
  \item \itab{Absorption:} \tab{\texttt{p ? mempty \ \ \ \ \ == mempty}}
  \item \itab{Distributivity:} \tab{\texttt{p ? (e <> f) \ \ \ == p ? e <> p ? f}}
  \item \itab{Conjunction:} \tab{\texttt{p ? q ? e \ \ \ \ \ \ == (p $\wedge$ q) ? e}}
  \item \itab{Complement:} \tab{\texttt{p ? e <> $\!\neg$p ? e == e}}
  \item \itab{Reordering:} \tab{\texttt{p ? e <> $\!\neg$p ? f  == $\neg$p ? f <> p ? e}}
\end{enumerate}

\todo{The above is true only for certain well-behaved predicates: need
termination and no observable effects? }

All expressions need to be modifiable by users of the build system. We therefore
need to provide a way not only to add new flags to an expression, but also to
modify and remove them. A simple way to achieve this is to switch to difference
list expressions:

\begin{lstlisting}[basicstyle=\ttfamily]
newtype Diff a = Diff { fromDiff :: a -> a }

type DiffExpr a = Expr (Diff a)

instance Monoid (Diff a) where
    mempty = Diff id
    Diff x `mappend` Diff y = Diff $ y . x
\end{lstlisting}

The reverse order of function composition \texttt{y . x} ensures that when two
\texttt{DiffExpr} computations are combined \texttt{c1 <> c2}, then \texttt{c1}
is applied first and \texttt{c2} is applied second. The following functions
can be used to append and remove items to/from a difference list:

\begin{lstlisting}[basicstyle=\ttfamily]
append :: Monoid a => a -> DiffExpr a
append x = return $ Diff (<> x)

remove :: Eq a => [a] -> DiffExpr [a]
remove xs = return $ Diff $ filter (`notElem` xs)
\end{lstlisting}

We are now ready to define \texttt{Args}, a type of expressions for constructing
command line arguments in the build system, and function \texttt{arg} for
injecting simple \texttt{String} arguments into \texttt{Args}:

\begin{lstlisting}[basicstyle=\ttfamily]
type Args = DiffExpr [String]

arg :: String -> Args
arg = append . return
\end{lstlisting}

With the above abstractions in place, we can construct command line arguments
for \texttt{Alex} as follows:

\begin{lstlisting}[basicstyle=\ttfamily]
alexArgs :: Args
alexArgs = mconcat [ arg "-g"
                   , package compiler ? arg "--latin1" 
                   , arg =<< getInput
                   , arg "-o", arg =<< getOutput ]
\end{lstlisting}

Here \texttt{getInput} and \texttt{getOutput} are expressions that check that
\texttt{Target.inputs} and \texttt{Target.outputs} contain exactly one value and
return it.

The resulting \texttt{alexArgs} expression is terse and readable. All
distracting plumbing details have been abstracted away so that the
designers and users of the build system could focus on what matters.


\noindent ----\\
\noindent The \texttt{build} function takes care of building a single
\texttt{Target}:
\begin{itemize}
  \item It computes the complete command line to build the target from the
  \texttt{Args} expression.
  \item If the command line has changed since the last invocation of the build
  system, the target is rebuilt even if all its dependencies are up-to-date.
  This tracks changes both in the environment and in the build system itself.
  \item It makes sure the required builder is up-to-date. Some builders are
  built by the build system, e.g. \texttt{genprimopcode}, \texttt{ghc-cabal},
  stage1 GHC, so it is important to rebuild them if need be.
  \item Finally, it runs the builder to build the target, printing diagnostic
  information if need be.
\end{itemize}

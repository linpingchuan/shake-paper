\section{Shaking up GHC\label{sec:ghc}}

In this section we report on our experience on applying the techniques presented
so far to building a large-scale software project: the Glasgow Haskell Compiler.

\todo{Andrey: list current limitations.}

\subsection{Analysis of common use-cases}
\begin{table*}[t]
\centering
\begin{tabular}{c | p{56mm} || p{50mm} | p{50mm}}
~
& \textbf{Use case}
& \textbf{Old build system} based on \make{}
& \textbf{New build system} based on Shake
\\
\hline
\hline
1 & Full clean build
& Everything is built, N sec \hfill \checkmark
& Everything is built, M sec \hfill \checkmark
\\
\hline
2 & Zero build \hspace{6.4mm}
& Nothing is rebuilt, 12.3 sec \hfill \checkmark
& Nothing is rebuilt, 3.7 sec \hfill \checkmark
\\
\hline
3 & Add comment: \textsf{libraries/base/Prelude.hs}
& \textsf{Prelude.o}, \textsf{base} library, and all
\newline dependent binaries are rebuilt
& Only \textsf{Prelude.o} is rebuilt \hfill \checkmark
\\
\hline
4 & Modify code: \hspace{1.75mm}\textsf{libraries/base/Prelude.hs}
& \textsf{Prelude.o} and all its dependencies \hfill \checkmark \newline
are rebuilt (almost everything)
& \textsf{Prelude.o} and all its dependencies \hfill \checkmark \newline
are rebuilt (almost everything)
\\
\hline
5 & Add comment: \textsf{utils/ghc-cabal/Main.hs}
& Almost everything is rebuilt, since \newline \textsf{package-data.mk} files
are changed & All \textsf{ghc-cabal} rules are rerun (due \newline
to non-deterministic GHC builds)
\\
\hline
6 & Modify code: \hspace{1.75mm}\textsf{utils/ghc-cabal/Main.hs}
& Almost everything is rebuilt
& Only the targets affected by the \newline change are rebuilt \hfill
\checkmark
\\
\hline
7 & Modify the build system: pass \textsf{-O2} when compiling Stage2 GHC
& Nothing is rebuilt, as build system \newline is not tracked
& Stage2 GHC and all its \newline dependencies are rebuilt \hfill \checkmark\\
\hline
8 & Modify the build system without changing command line arguments of build
tools
& Nothing is rebuilt
& Nothing is rebuilt
\\
\hline
9 & Switch to a \textsf{git} branch and back 
& Some files are rebuilt
& Nothing is rebuilt \hfill \checkmark
\\
\hline
10 & Change path to \textsf{gcc}
& Everything is rebuilt
& Files depending on \textsf{gcc} are rebuilt \hfill \checkmark
\\
\end{tabular}
\caption{Comparison of GHC build systems on common use cases
(using \textsf{quick} build flavour). Checkmarks \checkmark indicate expected
behaviour.}
\label{tab:use-cases}
\end{table*}


In this section we discuss several use-cases of the GHC build system, which
are fairly typical for build systems in general.

\subsubsection{Change nothing and rebuild}

Running a build system twice in a row should be equivalent to only running it
once. Moreover the second build should do nothing, as quickly as possible.
Such a do-nothing build is referred to as a \emph{zero build}. The time it takes
represents internal overheads of the build system: scanning the file system,
reading the database, etc.

\textbf{Outcome:} Both the old and the new build systems pass this test
successfully. Notably, the new one does this 3 times faster, as reported in
\S\ref{sec:benchmarks}.

\subsubsection{Change a source file and rebuild}

\begin{lstlisting}
$ build
$ build
\end{lstlisting}

Both \make{} and Shake work. Shake does fewer rebuilds. Several examples with
different rebuild chains.

\subsubsection{Add comments to \texttt{ghc-cabal} and rebuild}

Both \make{} and Shake work. \make{} ends up rebuilding everything. Shake only
reruns \texttt{ghc-cabal} and stops, as generated files are not changed.

\subsubsection{Change a command line in the build system and rebuild}

\make{} doesn't track such changes. Shake reruns only necessary rules.
Also show how changing a command line looks like in \make{} and in Shake.

\subsubsection{Switch between \texttt{git} branches and rebuild}

Consider the following sequence of commands, which can occur when working on
multiple \texttt{git} branches simultaneously:

\begin{lstlisting}
$ build
$ git checkout -b test
$ touch libraries/base/Prelude.hs
$ git checkout master
$ build
\end{lstlisting}

We expect the second \texttt{build} to do nothing, since the \texttt{master}
branch hasn't changed. However, \texttt{git branch master} changes modification
time of all files that were updated between branches, which forces \make{} to
rerun all dependent rules. Shake's ability to track file contents in addition to
modification time allows us to avoid such unnecessary rebuils, see
\S\ref{sec:file-contents}.

\textbf{Outcome:} the old build system does a partial rebuild, the new build
system rebuilds nothing.

\subsubsection{Change path to \texttt{gcc} and rebuild}

Both \make{} and Shake work. \make{} ends up rebuilding everything. Shake reruns
only necessary rules.

\subsubsection{Change build rules and rebuild}

Both \make{} and Shake don't notice this and fail to rebuild. Checking
equivalence is hard. Future work.

\subsection{Benchmarks\label{sec:benchmarks}}

\todo{Neil: your profiling results can go here}

Quantitative results: benchmarking, profiling, achieved parallelism.

We used parallelism to speed up some phases. Show profiles showing ghc-cabal was
a bottleneck.

\subsection{Things lint spotted}

\todo{Neil: I think I have only one good example: result of getDirectoryFiles
changed. Do we want to discuss it here? Maybe somewhere in the Shake section
instead?}

Most useful one is if two people whack the same output. Other thing is where
doing all .hs files in a dir, and then you generate one. Should this go
somewhere else? Perhaps in S5.

\subsection{Summary}

\todo{How we used better tools and abstractions to do better.}

\todo{Quantitative results: are we faster? Fewer lines of code? Fewer system
dependencies?}

\todo{Qualitative results: easier to understand and maintain. Can we
say this? Can we say that the new build system works in more environments,
because we have fewer dependencies?}


\subsection{Performance notes}

Zero build Shake

\begin{lstlisting}
shakeArgsWith                        0.001s    0%
Function shake                       0.156s    4%  =
Database read                        0.329s   10%  ===
With database                        0.021s    0%
Running rules                        2.502s   77%  =========================
Pool finished (7639 threads, 8 max)  0.001s    0%
Lint checking                        0.202s    6%  ==
Total                                3.211s  100%
Build completed in 0:04m

real    0m3.700s
\end{lstlisting}

Zero build with Make, real    0m12.342s


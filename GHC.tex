\section{Shaking up GHC\label{sec:ghc}}

In this section we report on our experience on applying the techniques presented
so far to building a large-scale software project: the Glasgow Haskell Compiler.

\todo{Andrey: list current limitations.}

\subsection{Qualitative analysis}

In this part we say how they both behave in different circumstances. In addition Shake gives us profiling reports, both from GHC and Shake itself.

\todo{Q: Drop full and zero from the table? These are a different type of analysis, and covered in benchmark}

\subsection{Analysis of common use-cases}
\begin{table*}[t]
\centering
\begin{tabular}{c | p{56mm} || p{50mm} | p{50mm}}
~
& \textbf{Use case}
& \textbf{Old build system} based on \make{}
& \textbf{New build system} based on Shake
\\
\hline
\hline
1 & Full clean build
& Everything is built, 1266 sec \hfill \checkmark
& Everything is built, 737 M sec \hfill \checkmark
\\
\hline
2 & Zero build \hspace{6.4mm}
& Nothing is rebuilt, 18.4 sec \hfill \checkmark
& Nothing is rebuilt, 2.1 sec \hfill \checkmark
\\
\hline
3 & Add comment: \textsf{libraries/base/Prelude.hs}
& \textsf{Prelude.o}, \textsf{base} library, and all
\newline dependent binaries are rebuilt
& Only \textsf{Prelude.o} is rebuilt \hfill \checkmark
\\
\hline
4 & Modify code: \hspace{1.75mm}\textsf{libraries/base/Prelude.hs}
& \textsf{Prelude.o} and all its dependencies \hfill \checkmark \newline
are rebuilt
& \textsf{Prelude.o} and all its dependencies \hfill \checkmark \newline
are rebuilt (40\% by time)
\\
\hline
5 & Add comment: \textsf{utils/ghc-cabal/Main.hs}
& Almost everything is rebuilt, since \newline \textsf{package-data.mk} files
are changed & All \textsf{ghc-cabal} rules are rerun (due \newline
to non-deterministic GHC builds)
\\
\hline
6 & Modify code: \hspace{1.75mm}\textsf{utils/ghc-cabal/Main.hs}
& Almost everything is rebuilt
& Only the targets affected by the \newline change are rebuilt \hfill
\checkmark
\\
\hline
7 & Modify the build system: pass \textsf{-O2} when compiling Stage2 GHC
& Nothing is rebuilt, as build system \newline is not tracked
& Stage2 GHC and all its \newline dependencies are rebuilt \hfill \checkmark\\
\hline
8 & Modify the build system without changing command line arguments of build
tools
& Nothing is rebuilt
& Nothing is rebuilt
\\
\hline
9 & Switch to a \textsf{git} branch and back
& Some files are rebuilt
& Nothing is rebuilt \hfill \checkmark
\\
\hline
10 & Change path to \textsf{gcc}
& Everything is rebuilt
& Files depending on \textsf{gcc} are rebuilt \hfill \checkmark
\\
\end{tabular}
\caption{Comparison of GHC build systems on common use cases
(using \textsf{quick} build flavour with 4 CPUs). Checkmarks \checkmark indicate expected
behaviour.}
\label{tab:use-cases}
\end{table*}


In this section we discuss several use-cases of the GHC build system, which
are fairly typical for build systems in general.

\subsubsection{Change nothing and rebuild}

Running a build system twice in a row should be equivalent to only running it
once. Moreover the second build should do nothing, as quickly as possible.
Such a do-nothing build is referred to as a \emph{zero build}. The time it takes
represents internal overheads of the build system: scanning the file system,
reading the database, etc.

\textbf{Outcome:} Both the old and the new build systems pass this test
successfully. Notably, the new one does this 3 times faster, as reported in
\S\ref{sec:benchmarks}.

\subsubsection{Change a source file and rebuild}

\begin{lstlisting}
$ build
$ build
\end{lstlisting}

Both \make{} and Shake work. Shake does fewer rebuilds. Several examples with
different rebuild chains.

\subsubsection{Add comments to \texttt{ghc-cabal} and rebuild}

Both \make{} and Shake work. \make{} ends up rebuilding everything. Shake only
reruns \texttt{ghc-cabal} and stops, as generated files are not changed.

\subsubsection{Change a command line in the build system and rebuild}

\make{} doesn't track such changes. Shake reruns only necessary rules.
Also show how changing a command line looks like in \make{} and in Shake.

\subsubsection{Switch between \texttt{git} branches and rebuild}

Consider the following sequence of commands, which can occur when working on
multiple \texttt{git} branches simultaneously:

\begin{lstlisting}
$ build
$ git checkout -b test
$ touch libraries/base/Prelude.hs
$ git checkout master
$ build
\end{lstlisting}

We expect the second \texttt{build} to do nothing, since the \texttt{master}
branch hasn't changed. However, \texttt{git branch master} changes modification
time of all files that were updated between branches, which forces \make{} to
rerun all dependent rules. Shake's ability to track file contents in addition to
modification time allows us to avoid such unnecessary rebuils, see
\S\ref{sec:file-contents}.

\textbf{Outcome:} the old build system does a partial rebuild, the new build
system rebuilds nothing.

\subsubsection{Change path to \texttt{gcc} and rebuild}

Both \make{} and Shake work. \make{} ends up rebuilding everything. Shake reruns
only necessary rules.

\subsubsection{Change build rules and rebuild}

Both \make{} and Shake don't notice this and fail to rebuild. Checking
equivalence is hard. Future work.

\subsection{Benchmarks\label{sec:benchmarks}}

When building from scratch, ignoring the initial boot/configure steps which are shared, the Make system takes 1266 seconds and the Shake one takes 737 seconds. These were tested in as similar configurations as we could manage, but due to the complexity of the build system, there are almost certain minor differences. For the build where nothing has changed, Make takes 18.4 seconds and Shake takes 2.1 seconds. \todo{optimise Shake}

Since Shake and Haskell both provide profiling and analysis tools, we have already used these features to optimise the Shake build, resulting in modest gains sofar and several opportunities we have yet to exploit. Looking at the full build number of Shake, it takes 737 seconds, the longest single task is building the GMP library (315 seconds), and total amount of single threaded computation is 2206 seconds, of which 2099 is calling out to external processes. The critical dependency path has 378 steps on it, and requires 463 seconds -- a lower bound on the time even if we have an unlimited number of processors.

\subsection{Summary}

\todo{How we used better tools and abstractions to do better.}

\todo{Quantitative results: are we faster? Fewer lines of code? Fewer system
dependencies?}

\todo{Qualitative results: easier to understand and maintain. Can we
say this? Can we say that the new build system works in more environments,
because we have fewer dependencies?}



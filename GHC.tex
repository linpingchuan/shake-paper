\begin{table*}[t]
\centering
\begin{tabular}{p{60mm} || p{50mm} | p{50mm}}
\textbf{Use case}
& \textbf{Old build system} based on Make
& \textbf{New build system} based on Shake
\\
\hline
\textsf{U1:} Fully-featured GHC build
& Everything is built \hfill \checkmark
& Not all features supported, see~\S\ref{sec:limitations}
\\
\textsf{U2:} Clean build
& Everything is built \hfill \checkmark
& Everything is built \hfill \checkmark
\\
\textsf{U3:} Zero build \hspace{6.4mm}
& Nothing is rebuilt \hfill \checkmark
& Nothing is rebuilt \hfill \checkmark
\\
\hline
\textsf{U4:} Add comment: \textsf{libraries/base/Prelude.hs}
& \textsf{Prelude.o}, \textsf{base} library, and all
\newline dependent binaries are rebuilt
& Only \textsf{Prelude.o} is rebuilt \hfill \checkmark
\\
\textsf{U5:} Modify code: \hspace{1.75mm}\textsf{libraries/base/Prelude.hs}
& \textsf{Prelude.o} and all its dependencies \hfill \checkmark \newline
are rebuilt
& \textsf{Prelude.o} and all its dependencies \hfill \checkmark \newline
are rebuilt
\\
\textsf{U6:} Add comment: \textsf{utils/ghc-cabal/Main.hs}
& Almost everything is rebuilt
& All \textsf{ghc-cabal} rules are rerun
\\
\textsf{U7:} Modify code: \hspace{1.75mm}\textsf{utils/ghc-cabal/Main.hs}
& Almost everything is rebuilt
& Only the targets affected by the \hfill \checkmark \newline change are rebuilt
\\
\hline
\textsf{U8:} Modify the build system: pass \textsf{-O2} when\newline
$\textit{~~~~~~~}$compiling Stage2 GHC
& Nothing is rebuilt
& Stage2 GHC and its dependencies \hfill \checkmark \newline are rebuilt
\\
\textsf{U9:} Modify the build system without changing \newline
$\textit{~~~~~~~}$command line arguments of build tools
& Nothing is rebuilt
& Nothing is rebuilt
\\
\hline
\textsf{U10:} Switch to a \textsf{git} branch and back
& Some files are rebuilt
& Nothing is rebuilt \hfill \checkmark
\\
\textsf{U11:} Change path to \textsf{gcc}
& Everything is rebuilt
& Files depending on \textsf{gcc} are rebuilt \hfill \checkmark
\\
\end{tabular}
\caption{Comparison of GHC build systems on common use cases. Checkmarks
\checkmark indicate expected behaviour.}
\label{tab:use-cases}
\end{table*}

\section{Shaking up GHC\label{sec:ghc}}

In this section we report on our experience on applying the techniques presented
so far to building a large-scale software project: the Glasgow Haskell Compiler.

\subsection{Current limitations\label{sec:limitations}}

We implemented a new build system for GHC using Shake and our build
abstractions~\S\ref{sec:abstractions}. The current implementation can build
\lst'Stage2' GHC, but has the following limitations:
\begin{itemize}
  \item We only build \lst'vanilla' and \lst'profiling' way.
  \item We reuse GHC testing infrastructure of the old build system.
  \item Only HTML documentation can be built.
  \item Not all build flavours and command line flags are supported.
  \item Cross-compilation is not implemented.
  \item Installation or binary/source distribution are not supported.
\end{itemize}

\noindent We intend to fix the above in the near future; nothing presents any
new challenges or requires changes to the current infrastructure.

\subsection{Qualitative analysis\label{sec:use-cases}}

In this section we discuss several use cases of the GHC build system, which
are fairly typical for build systems in general. Table~\ref{tab:use-cases}
lists use cases \lst'U1-U11' highlighting differences between the old and the
new build systems. Below we go through some of the use cases in more detail.
See~\S\ref{sec:benchmarks} for performance comparison.

\lst'U1-U3' are simplest use cases. For the sake of fairness we start with
\lst'U1', where the old build system reigns over our current implementation due
to the aforementioned limitations. When unsupported features are not used
(\lst'U2'), the new build system successfully builds all expected targets.
Running a build system twice in a row must be equivalent to only running it
once; the second build must do nothing, hence the name \emph{zero
build} (\lst'U3'). The new build system works as expected, and is much faster
than the old one (see \S\ref{sec:benchmarks}).

% The time it takes represents internal overheads of the build system:
% scanning the file system, reading the database, etc. 

In \lst'U4-U5' we modify \lst'libraries/base/Prelude.hs' and rebuild GHC.
When only comments are added (\lst'U4'), the new build system recompiles the
file, notices the object code is unchanged, and stops: there is nothing else to
be done. The old build system continues to rebuild the \lst'base' library as
well as all dependent binaries, which is unnecessary. In \lst'U5' the
modification of \lst'Prelude.hs' leads to changes in \lst'Prelude.o', which
causes all dependencies to be rebuilt. Both build systems handle this case
correctly.

\lst'U6-U7' are similar, but we now modify sources of \lst'ghc-cabal' build
tool. The old build system rebuilds almost everything in both cases,
which is unnecessary. Rebuilds are caused by rerunning updated \lst'ghc-cabal'
binary, which changes modification time of generated \lst'package-data.mk'
files. The lack of polymorphic dependencies means we have to depend on the whole
file when using Make, therefore even if only one field in a
\lst'package-data.mk' file is changed, e.g. \lst'CC_OPTS', we end up
rebuilding everything, not only C compilation rules that depend on
\lst'CC_OPTS'. The new build system uses Shake's polymorphic
dependencies~\S\ref{sec:polymorphic} to avoid such unnecessary rebuilds. Note
however, that \lst'U6' behaviour is still suboptimal: \lst'ghc-cabal' rules
are rerun, because GHC currently produces non-deterministic output
(\lst'ghc-cabal''s binary is changed).

In \lst'U8' we modify the build system itself by changing command line
arguments for one of the build files. The old build system rebuilds nothing,
as Make does not track such changes. The new build system correctly reruns all
affected rules. We currently only track command line arguments, therefore if one
does other, more subtle modifications (\lst'U9'), they will be unnoticed.

Working with multiple \lst'git' branches is a problematic use-case for build
systems based on Make (see second bullet point in \S\ref{sec:file-contents}). In
\lst'U10' we conduct the following simple experiment:

\begin{lstlisting}
$ build
$ git checkout -b test
$ touch libraries/base/Prelude.hs
$ git checkout master
$ build
\end{lstlisting}

We expect the second \lst'build' to do nothing, since the \lst'master'
branch has not changed. However, \lst'git checkout master' changes modification
time of all files that were updated between branches, forcing the new
build system to rerun all dependent rules (as in \lst'U4'). Shake's ability to
track file contents~\S\ref{sec:file-contents} in addition to modification time allows us to
avoid such unnecessary rebuils.

In \lst'U11' we modify the build environment, by changing the path to \lst'gcc'
in the configuration file. As in \lst'U6-U7', the old build system rebuilds
almost everything since depending on a single configuration setting is not
supported. The new build system correctly reruns only affected rules.

In summary, the new build system correctly handles most use cases, whereas
the old one performs a lot of unnecessary rebuilds in all but simple cases. In
the next section we show that the new build system is also faster.

\subsection{Benchmarks\label{sec:benchmarks}}

When building from scratch, ignoring the initial boot/configure steps which are shared, the Make system takes 1266 seconds and the Shake one takes 737 seconds. These were tested in as similar configurations as we could manage, but due to the complexity of the build system, there are almost certain minor differences. For the build where nothing has changed, Make takes 12.3 seconds and Shake takes 2.1 seconds. \todo{optimise Shake}

Since Shake and Haskell both provide profiling and analysis tools, we have already used these features to optimise the Shake build, resulting in modest gains sofar and several opportunities we have yet to exploit. Looking at the full build number of Shake, it takes 737 seconds, the longest single task is building the GMP library (315 seconds), and total amount of single threaded computation is 2206 seconds, of which 2099 is calling out to external processes. The critical dependency path has 378 steps on it, and requires 463 seconds -- a lower bound on the time even if we have an unlimited number of processors.

\subsection{Summary}

\todo{How we used better tools and abstractions to do better.}

\todo{Quantitative results: are we faster? Fewer lines of code? Fewer system
dependencies?}

\todo{Qualitative results: easier to understand and maintain. Can we
say this? Can we say that the new build system works in more environments,
because we have fewer dependencies?}



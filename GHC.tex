\section{Shaking up GHC\label{sec:ghc}}

In this section we report on our experience on applying the techniques presented
so far to building a large-scale software project: the Glasgow Haskell Compiler.

\todo{Andrey: list current limitations.}

\subsection{Analysis of common use-cases}

In this section we discuss several use-cases of the GHC build system, which
are fairly typical for build systems in general.

\subsubsection{Change nothing and rebuild}

Running a build system twice in a row should be equivalent to only running it
once. Moreover the second build should do nothing, as quickly as possible.
Such a do-nothing build is referred to as a \emph{zero build}. The time it takes
represents internal overheads of the build system: scanning the file system,
reading the database, etc.

\textbf{Outcome:} Both the old and the new build systems pass this test
successfully. Notably, the new one does this 3 times faster, as reported in
\S\ref{sec:benchmarks}.

\subsubsection{Change a source file and rebuild}

\begin{lstlisting}
$ build
$ build
\end{lstlisting}

Both \make{} and Shake work. Shake does fewer rebuilds. Several examples with
different rebuild chains.

\subsubsection{Add comments to \texttt{ghc-cabal} and rebuild}
 
Both \make{} and Shake work. \make{} ends up rebuilding everything. Shake only
reruns \texttt{ghc-cabal} and stops, as generated files are not changed.

\subsubsection{Change a command line in the build system and rebuild}

\make{} doesn't track such changes. Shake reruns only necessary rules.
Also show how changing a command line looks like in \make{} and in Shake.

\subsubsection{Switch between \texttt{git} branches and rebuild}
 
Consider the following sequence of commands, which can occur when working on
multiple \texttt{git} branches simultaneously:

\begin{lstlisting}
$ build
$ git checkout -b test
$ touch libraries/base/Prelude.hs
$ git checkout master
$ build
\end{lstlisting}

We expect the second \texttt{build} to do nothing, since the \texttt{master}
branch hasn't changed. However, \texttt{git branch master} changes modification
time of all files that were updated between branches, which forces \make{} to
rerun all dependent rules. Shake's ability to track file contents in addition to
modification time allows us to avoid such unnecessary rebuils, see
\S\ref{sec:file-contents}.

\textbf{Outcome:} the old build system does a partial rebuild, the new build
system rebuilds nothing.
 
\subsubsection{Change path to \texttt{gcc} and rebuild}
 
Both \make{} and Shake work. \make{} ends up rebuilding everything. Shake reruns
only necessary rules.

\subsubsection{Change build rules and rebuild}
 
Both \make{} and Shake don't notice this and fail to rebuild. Checking
equivalence is hard. Future work.

\subsection{Benchmarks\label{sec:benchmarks}}

\todo{Neil: your profiling results can go here}

Quantitative results: benchmarking, profiling, achieved parallelism.

We used parallelism to speed up some phases. Show profiles showing ghc-cabal was
a bottleneck.

\subsection{Things lint spotted}

\todo{Neil: I think I have only one good example: result of getDirectoryFiles
changed. Do we want to discuss it here? Maybe somewhere in the Shake section
instead?}

Most useful one is if two people whack the same output. Other thing is where
doing all .hs files in a dir, and then you generate one. Should this go
somewhere else? Perhaps in S5.

\subsection{Summary}

\todo{How we used better tools and abstractions to do better.}

\todo{Quantitative results: are we faster? Fewer lines of code? Fewer system
dependencies?}

\todo{Qualitative results: easier to understand and maintain. Can we
say this? Can we say that the new build system works in more environments,
because we have fewer dependencies?}


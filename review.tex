\section{Review of state-of-the-art in build systems\label{section-review}}

This paper is about writing build systems at scale, a subject without much literature since \citet{miller:recursive_make}. When \citet{mcintosh:build_maintenance_effort} studied software maintenance they found that build systems can take up to 27\% of development effort, and that improvements to the build system rapidly paid off. Recently \citet{martin:make_it_simple, martin:maintenance_complexity_makefiles} has both surveyed which Make features are used, and classified them by complexity -- unsurprisingly they found that as Makefiles grow, their complexity increases, and that the features required for hand written Makefiles are those which are most complex. In the remainder of this section we focus on some of the features found in other build systems which could be useful at large scale.

\subsection{Embedded language}

A build system can either be specified using structured metadata (e.g. Bazel \cite{bazel}), or embedded into a language -- for example SCons uses Python \cite{scons}, Pluto uses Java \cite{pluto} and Jenga uses OCaml \cite{jenga}. We make essential use of custom code throughout (\S\ref{sec:real_code}, \S\ref{sec:abstractions}), which essentially allows us to write most of our build system in our own metadata tailored to our specific project. While we are particularly fond of functional languages, such an approach could equally be taken in non-functional languages.

Even sticking to Haskell as the embedded language, there are a surprisingly large number of libraries implementing a dependency aware build system -- we know of eleven in addition to Shake (Abba, Blueprint, Buildsome, Coadjute, Cake $\times$ 2, Hake, Hmk, Nemesis, OpenShake and Zoom). Of these, the two Cake libraries and OpenShake are based on an early presentation of the principles behind Shake.

\subsection{Advanced dependencies}

We have found that while powerful dependencies might only be used in a few places, if they are missing the workarounds can be pervasive (\S\ref{sec:dynamic-deps}). A few other build systems support resources (e.g. Ninja \cite{ninja}), and several support monadic dependencies (Redo \cite{redo}, Jenga, Pluto, SCons). A few build systems directly support dependency features more powerful than Shake, for example Pluto supports rules that run until a fixed-point and rules whose output is not known in advance. These features can be encoded in Shake, but are not present natively.

\subsection{Automatic dependency management}

In both Shake and Make, all dependencies must be declared explicitly. However, in build systems such as Tup \cite{tup} and Buildsome \cite{buildsome} dependencies are automatically detected by monitoring the system, albeit only after the dependency has been used (as per \lst'needed' in \S\ref{sec:needed}). The Fabricate tool \cite{fabricate} takes a unique approach to defining build systems, providing a series of steps run sequentially and are skipped if their inputs have not changed, again relying on automatically detecting dependencies. Since no cross-platform APIs are available to detect accessed dependencies, such tools tend to have portability concerns.

\subsection{Build clusters}

The build systems Bazel and Buck \cite{buck} are used at Google and Facebook respectively, both operating at sizes significantly beyond that of the GHC build system (reportedly billions of lines of code). Both systems take a metadata approach, with statements such as \lst'cxx_binary' which given the C++ source code and output, does all building. The disadvantage of such an approach is that the available rules are static, making it difficult to encode something like a bootstrapping compiler. Generated source code is not really supported -- a problem typically solved by checking in generated files. Both features also support build clusters which build code once and share the resulting objects to everyone without recompiling locally, an essential feature at such scales.
